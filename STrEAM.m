(* ::Package:: *)

(* ::Title:: *)
(*STrEAM.m Package*)


(* ::Text:: *)
(*SuperTrace Evaluation Automated for Matching*)
(*by Timothy Cohen, Xiaochuan Lu, and Zhengkang Zhang*)
(*Last edited on December 06, 2020.*)


(* ::Section:: *)
(*Begin the package*)


(* ::Input::Initialization:: *)
BeginPackage["STrEAM`"]


(* ::Subsection:: *)
(*Usage messages for the public functions*)


(* ::Input::Initialization:: *)
(* Reserved for input recognition *)
P::usage="\!\(\*SubscriptBox[\(P\), \(\[Mu]\)]\)=\!\(\*SubscriptBox[\(iD\), \(\[Mu]\)]\) denote the Hermitian covariant derivatives in input and output.";
\[CapitalDelta]::usage="\!\(\*SubscriptBox[\(\[CapitalDelta]\), \(i\)]\)=\!\(\*FractionBox[\(1\), \(\*SuperscriptBox[\(P\), \(2\)] - \*SubsuperscriptBox[\(m\), \(i\), \(2\)]\)]\) denotes bosonic covariant propagators in input and its print.";
\[CapitalLambda]::usage="\!\(\*SubscriptBox[\(\[CapitalLambda]\), \(i\)]\)=\!\(\*FractionBox[\(1\), \(Pslash - \*SubscriptBox[\(m\), \(i\)]\)]\) denotes fermionic covariant propagators in input and its print.";

(* Reserved as dummy indices *)
\[Mu]::usage="\!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\) denote dummy indices in output.";
\[Rho]::usage="\!\(\*SubscriptBox[\(\[Rho]\), \(i\)]\) denote dummy indices in output.";

(* Reserved for output *)
m::usage="\!\(\*SubscriptBox[\(m\), \(i\)]\) with i non-negative integers denote particle masses.";
d::usage="d denotes the spacetime dimension in dimensional regularization.";
\[Eta]::usage="\!\(\*SubscriptBox[\(\[Eta]\), \(\[Mu], \[Nu]\)]\)=diag(1,-1,-1,-1) denotes the spacetime metric.";
F::usage="\!\(\*SubscriptBox[\(F\), \(\[Mu], \[Nu]\)]\)=-i[\!\(\*SubscriptBox[\(P\), \(\[Mu]\)]\),\!\(\*SubscriptBox[\(P\), \(\[Nu]\)]\)]=\!\(\*SubscriptBox[\(g\), \(a\)]\)\!\(\*SubsuperscriptBox[\(G\), \(\[Mu]\[Nu]\), \(a\)]\)\!\(\*SuperscriptBox[\(T\), \(a\)]\) denotes the sum of field strengths.";
\[Gamma]::usage="\!\(\*SubscriptBox[\(\[Gamma]\), \(\[Mu]\)]\) denote Dirac matrices.";
\[Sigma]F::usage="\[Sigma]F denotes \!\(\*SuperscriptBox[\(\[Sigma]\), \(\[Mu]\[Nu]\)]\)\!\(\*SubscriptBox[\(F\), \(\[Mu]\[Nu]\)]\)=\!\(\*FractionBox[\(i\), \(2\)]\)[\!\(\*SuperscriptBox[\(\[Gamma]\), \(\[Mu]\)]\),\!\(\*SuperscriptBox[\(\[Gamma]\), \(\[Nu]\)]\)]\!\(\*SubscriptBox[\(F\), \(\[Mu]\[Nu]\)]\) in the dipole factor \[CapitalSigma]=-\!\(\*FractionBox[\(1\), \(2\)]\)\!\(\*SuperscriptBox[\(\[Sigma]\), \(\[Mu]\[Nu]\)]\)\!\(\*SubscriptBox[\(F\), \(\[Mu]\[Nu]\)]\).";
Pslash::usage="Pslash=\!\(\*SubscriptBox[\(P\), \(\[Mu]\)]\)\!\(\*SuperscriptBox[\(\[Gamma]\), \(\[Mu]\)]\)";
LoopI::usage="\!\(\*FractionBox[\(1\), \(16 \*SuperscriptBox[\(\[Pi]\), \(2\)]\)]\)\!\(\*SubsuperscriptBox[\(LoopI\), \((\*SubscriptBox[\(n\), \(1\)],  ... , \*SubscriptBox[\(n\), \(k\)])\), \((r)\)]\)(\!\(\*SubsuperscriptBox[\(m\), \(1\), \(2\)]\),...,\!\(\*SubsuperscriptBox[\(m\), \(k\), \(2\)]\))=-i\[Integral]\!\(\*FractionBox[\(\*SuperscriptBox[\(d\), \(d\)] q\), SuperscriptBox[\((2  \[Pi])\), \(d\)]]\)\!\(\*FractionBox[SuperscriptBox[\((\*SuperscriptBox[\(q\), \(2\)])\), \(r\)], \(\(\*SuperscriptBox[\((\*SuperscriptBox[\(q\), \(2\)] - \*SubsuperscriptBox[\(m\), \(1\), \(2\)])\), SubscriptBox[\(n\), \(1\)]] ... \) \*SuperscriptBox[\((\*SuperscriptBox[\(q\), \(2\)] - \*SubsuperscriptBox[\(m\), \(k\), \(2\)])\), SubscriptBox[\(n\), \(k\)]]\)]\)";

(* Main Functions *)
SuperTrace::usage="SuperTrace[dim,flist] evaluates -iSTr[f]\!\(\*SubscriptBox[\(|\), \(hard\)]\) up to operator dimension dim.";
SuperTraceFromExpr::usage="SuperTraceFromExpr[dim,fexpr] evaluates -iSTr[f]\!\(\*SubscriptBox[\(|\), \(hard\)]\) up to operator dimension dim.";


(* ::Section:: *)
(*Begin the `Private context*)


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Subsection:: *)
(*qSection Manipulations*)


(* ::Text::Closed:: *)
(*Descriptions*)


(* ::Input::Initialization:: *)
(*
"qSec" stores the q-sections (loop momentum dependence) of terms in intermediate steps in the CDE procedure;
They are essentially just functions in the loop momentum Subscript[q, \[Mu]];
When generated by CDE, they are polynomials of Subscript[q, \[Mu]], Subscript[dq, \[Mu]](derivatives on Subscript[q, \[Mu]]), and Subscript[\[CapitalDelta], i]=1/(q^2-Subsuperscript[m, i, 2]);
Note that in the context of "qSec", Subscript[\[CapitalDelta], i] is understood as an ordinary loop propagator, different from an input "Subscript[\[CapitalDelta], i]", where it is interpreted as Subsuperscript[\[CapitalDelta], i, CDE] (see later sections);

Concretely, a "qSec" is a list of "qPart", while a "qPart" is simply a list of factors, such as
qPart={1/30,Subscript[\[CapitalDelta], 1],Subscript[q, Subscript[\[Mu], 4]],Subscript[dq, Subscript[\[Mu], 1]],Subscript[dq, Subscript[\[Mu], 2]],Subscript[dq, Subscript[\[Mu], 3]],Subscript[dq, Subscript[\[Mu], 5]],Subscript[\[CapitalDelta], 1]};

In the end, the derivatives Subscript[dq, \[Mu]] in qSec will be carried out and the loop integral
-i\[Integral](d^dq)/(2\[Pi])^d will be performed on qSec;
The function LoopInt is parameterized as
1/(16\[Pi]^2)Subsuperscript[LoopI, (Subscript[n, 1],...,Subscript[n, k]), (r)](\!\(
\*SubsuperscriptBox[\(m\), \(1\), \(2\)],  ... , 
\*SubsuperscriptBox[\(m\), \(k\), \(2\)]\))=-i\[Integral](d^dq)/(2\[Pi])^d(q^2)^r/((q^2-Subsuperscript[m, 1, 2])^Subscript[n, 1]...(q^2-Subsuperscript[m, k, 2])^Subscript[n, k]);
which is evaluated using dim reg (d=4-2\[Epsilon]) under the MSbar scheme;
When there are less than three distinct masses, LoopInt returns the explicit value;
When there are three or more non-degenerate masses, LoopInt leaves the result abstract as the LHS above.
*)


(* ::Subsubsection::Closed:: *)
(*qSec and qPart Arithmetic*)


(* ::Input::Initialization:: *)
Clear[qPartCommuting];
Clear[q2dq2\[Eta]2Rules]; 
Clear[SplitqPart];
Clear[ExprqPart];
Clear[qPartFromExpr];
Clear[SimplifyqPart];
Clear[SimplifyqSec]; 
Clear[ScaleqPart];
Clear[ScaleqSec];
Clear[MultiplyqSecs];


(* ::Input::Initialization:: *)
(* Commuting condition for two adjacent elements in qPart *)
qPartCommuting=(MatchQ[#1,Subscript[dq, __]]&&MatchQ[#2,Subscript[dq, __]])||(!MatchQ[#1,Subscript[dq, __]]&&!MatchQ[#2,Subscript[dq, __]])&;

(* Rules for writing Subsuperscript[q, \[Nu], 2], Subsuperscript[dq, \[Nu], 2], and Subsuperscript[\[Eta], a_, 2] *)
q2dq2\[Eta]2Rules={\!\(
\*SubsuperscriptBox[\(q\), \(\[Nu]_\), \(2\)] -> \({
\*SubscriptBox[\(q\), \(\[Nu]\)], 
\*SubscriptBox[\(q\), \(\[Nu]\)]}\)\),\!\(
\*SubsuperscriptBox[\(dq\), \(\[Nu]_\), \(2\)] -> \({
\*SubscriptBox[\(dq\), \(\[Nu]\)], 
\*SubscriptBox[\(dq\), \(\[Nu]\)]}\)\),\!\(
\*SubsuperscriptBox[\(\[Eta]\), \(a__\), \(2\)] -> \({
\*SubscriptBox[\(\[Eta]\), \(a\)], 
\*SubscriptBox[\(\[Eta]\), \(a\)]}\)\)};

(* Split a qPart into commuting segments, with the first one reserved for coefficient *)
SplitqPart[qPart_]:=Module[{coeff,myqPart,myqPartSplit},
coeff=Times@@(Cases[qPart,_?NumericQ]);
myqPart=Join[Cases[qPart,Subscript[m, __]],Cases[qPart,Subscript[\[Eta], __]],DeleteCases[qPart,_?NumericQ|Subscript[m, __]|Subscript[\[Eta], __]]];
myqPartSplit=Join[{{coeff}},Split[myqPart,qPartCommuting]];
Return[myqPartSplit];
];

(* Get the "qPart expression" from a qPart list *)
ExprqPart[qPart_]:=Module[{qPartGrouped,myqPartSplit,myexpr},
myqPartSplit=SplitqPart[qPart];
qPartGrouped=(Times@@#)&/@myqPartSplit;
myexpr=If[Length[qPartGrouped]>2,qPartGrouped[[1]] NonCommutativeMultiply@@qPartGrouped[[2;;]],Times@@qPartGrouped];
Return[myexpr];
];

(* Convert a "qPart expression" back to the qPart list *)
qPartFromExpr[expr_]:=Module[{myqPart},
myqPart=Flatten[{expr/.{Times->List,NonCommutativeMultiply->List}/.q2dq2\[Eta]2Rules}];
If[!NumericQ[myqPart[[1]]],myqPart=Insert[myqPart,1,1]];
Return[myqPart];
];

(* Simplify a qPart to its canonical form via "qPart expression" *)
SimplifyqPart[qPart_]:=Module[{myexpr,myqPart},
myexpr=ExprqPart[qPart];
myqPart=qPartFromExpr[myexpr];
Return[myqPart];
];

(* Simplify a qSec to its canonical form via "qPart expression" *)
SimplifyqSec[qSec_]:=Module[{qSecexpr,exprArray,myqSec},
qSecexpr=Plus@@(ExprqPart[#]&/@qSec);
exprArray=Flatten[{qSecexpr/.Plus->List}];
myqSec=qPartFromExpr[#]&/@exprArray;
Return[myqSec];
];

(* Scale a qPart by a constant coeff, which does not depend on q or dq *)
ScaleqPart[qPart_,coeff_]:=Module[{myqPart},
myqPart=SimplifyqPart[qPart];
myqPart[[1]]=coeff*myqPart[[1]];
myqPart=SimplifyqPart[myqPart];
Return[myqPart];
];

(* Scale a qSec by a constant coeff, which does not depend on q or dq *)
ScaleqSec[qSec_,coeff_]:=Module[{myqSec},
myqSec=ScaleqPart[#,coeff]&/@qSec;
Return[myqSec];
];

(* Multiply a list of qSecs into a qSec *)
MultiplyqSecs[qSeclist_]:=Module[{myqSec},
myqSec=Flatten/@Tuples[qSeclist];
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];


(* ::Subsubsection::Closed:: *)
(*Derivatives and Integrals*)


(* ::Input::Initialization:: *)
Clear[dqCommRules];
Clear[dqLastqPart];
Clear[dqLastqSec];
Clear[dqAllqPart];
Clear[dqAllqSec];
Clear[qEvenTrimqSec];

Clear[\[Eta]ContractionRules];
Clear[qContractionRules];
Clear[AllPairings];
Clear[LoopInt];
Clear[SymHardqPart];
Clear[SymHardqSec];
Clear[IntegrateqPart];
Clear[IntegrateqSec];


(* ::Input::Initialization:: *)
(* Replacement rules for dq commutators *)
dqCommRules={{Subscript[dq, \[Mu]_],_?NumericQ}->{0},{Subscript[dq, \[Mu]_],Subscript[\[Eta], __]}->{0},{Subscript[dq, \[Mu]_],Subscript[m, __]}->{0},{Subscript[dq, \[Mu]_],Subscript[q, \[Nu]_]}->{Subscript[\[Eta], \[Mu],\[Nu]]},{Subscript[dq, \[Mu]_],Subscript[\[CapitalDelta], m_]}->{-2,Subscript[q, \[Mu]],\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(m\), \(2\)]\)},{Subscript[dq, \[Mu]_],\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(m_\), \(n_\)]\)}->{-2n,Subscript[q, \[Mu]],\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(m\), \(n + 1\)]\)}};

(* Carry out the last dq in a qPart to obtain a qSec *)
dqLastqPart[qPart_]:=Module[{myqPart,poslist,pos,myqSec},
myqPart=SimplifyqPart[qPart];
poslist=Flatten[Position[myqPart,Subscript[dq, __]]];
(* return when there is no dq to carry out *)
If[Length[poslist]==0,
	myqSec={myqPart};
	Return[myqSec];
];
pos=Last[poslist];
(* write qPart into a series of dq commutators *)
myqSec=Join[myqPart[[;;pos-1]],myqPart[[pos+1;;#-1]],{{myqPart[[pos]],myqPart[[#]]}},myqPart[[#+1;;]]]&/@Range[pos+1,Length[myqPart]];
(* carry out the dq commutators *)
myqSec=Flatten/@(myqSec/.dqCommRules);
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];

(* Carry out the last dq in a qSec to obtain a qSec *)
dqLastqSec[qSec_]:=Module[{myqSec},
myqSec=SimplifyqSec[qSec];
myqSec=Flatten[dqLastqPart/@myqSec,1];
Return[myqSec];
];

(* Carry out all dq in a qPart to obtain a qSec *)
dqAllqPart[qPart_]:=Module[{ii,ndq,myqSec},
ndq=Count[qPart,Subscript[dq, __]];
myqSec={qPart};
myqSec=Nest[dqLastqSec,myqSec,ndq];
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];

(* Carry out all dq in a qSec to obtain a qSec *)
dqAllqSec[qSec_]:=Module[{myqSec},
myqSec=Flatten[dqAllqPart/@qSec,1];
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];

(* Drop the qParts in a qSec that are odd under q\[Rule]-q *)
qEvenTrimqSec[qSec_]:=Module[{myqSec},
myqSec=Select[qSec,EvenQ[Count[#,Subscript[q, __]]+Count[#,Subscript[dq, __]]]&];
If[myqSec==={},myqSec={{0}}];
Return[myqSec];
];

(* \[Eta] contraction rules *)
\[Eta]ContractionRules={Subscript[\[Eta], \[Mu]_,\[Nu]_] Subscript[\[Eta], \[Mu]_,\[Rho]_]->Subscript[\[Eta], \[Nu],\[Rho]],Subscript[\[Eta], \[Mu]_,\[Nu]_] Subscript[\[Eta], \[Rho]_,\[Mu]_]->Subscript[\[Eta], \[Nu],\[Rho]],Subscript[\[Eta], \[Nu]_,\[Mu]_] Subscript[\[Eta], \[Mu]_,\[Rho]_]->Subscript[\[Eta], \[Nu],\[Rho]],Subscript[\[Eta], \[Nu]_,\[Mu]_] Subscript[\[Eta], \[Rho]_,\[Mu]_]->Subscript[\[Eta], \[Nu],\[Rho]],Subscript[\[Eta], \[Mu]_,\[Mu]_]->d,\!\(
\*SubsuperscriptBox[\(\[Eta]\), \(__\), \(2\)] -> d\),Subscript[a__, \[Mu]_] Subscript[\[Eta], \[Mu]_,\[Nu]_]->Subscript[a, \[Nu]],Subscript[a__, \[Mu]_] Subscript[\[Eta], \[Nu]_,\[Mu]_]->Subscript[a, \[Nu]]};

(* q contraction rules *)
qContractionRules={\!\(
\*SubsuperscriptBox[\(q\), \(__\), \(2\)] -> 
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(-1\)]\)};

(* Get the list of all pairings for an even number of objects *)
AllPairings[{}]:={{}};
AllPairings[{a_,b_}]:={{{a,b}}};
AllPairings[{a_,b__}]:=Flatten[Table[Prepend[{a,{b}[[i]]}]/@AllPairings[Delete[{b},i]],{i,Length[{b}]}],1];

(* A generic Loop Integral evaluated with dim-reg and MSbar scheme, multiplied by 16\[Pi]^2 *)
LoopInt[r_,nlist_,masslist_,coeff_]:=Module[{nlen,n,M,n1,n2,M1,M2,myResult},
nlen=Length[nlist];
If[nlen==0,Return[0]];
If[nlen==1,
	n=First[nlist];M=First[masslist];
	(* dim-reg *)
	myResult=coeff 1/(4\[Pi])^(d/2-2) (-1)^(n-r)/(M^2)^(n-r-d/2) Gamma[r+d/2]/Gamma[d/2] Gamma[n-r-d/2]/Gamma[n];
	(* MSbar scheme *)
	myResult=SeriesCoefficient[1/((4\[Pi])^\[Epsilon] Gamma[1+\[Epsilon]]) (myResult/.{d->4-2\[Epsilon]}),{\[Epsilon],0,0}];
	Return[myResult];
];
If[nlen==2,
	n1=nlist[[1]];n2=nlist[[2]];M1=masslist[[1]];M2=masslist[[2]];
	(* dim-reg *)
	myResult=coeff 1/(4\[Pi])^(d/2-2) (-1)^(n1+n2-r)/(M1^2)^(n1+n2-r-d/2) Gamma[r+d/2]/Gamma[d/2] Gamma[n1+n2-r-d/2]/Gamma[n1+n2];
	myResult=myResult*Hypergeometric2F1[n1+n2-r-d/2,n2,n1+n2,1-M2^2/M1^2];
	(* MSbar scheme *)
	myResult=SeriesCoefficient[1/((4\[Pi])^\[Epsilon] Gamma[1+\[Epsilon]]) (myResult/.{d->4-2\[Epsilon]}),{\[Epsilon],0,0}];
	Return[myResult];
];
myResult=Subsuperscript[LoopI,Row[Join[{"("},Riffle[nlist,","],{")"}]],Row[{"(",r,")"}]];
myResult=coeff Row[Join[{myResult,"("},{Row[masslist^2,","]},{")"}]];
Return[myResult];
];

(* Symmetrize qPart and expand in hard region to get a qSec before performing the q integral *)
SymHardqPart[qPart_,Heavylist_,LightOrd_]:=Module[{q\[Mu]list,\[CapitalDelta]list,coeff,npair,\[Eta]listArray,Mpattern,\[CapitalDelta]Mexpr,\[CapitalDelta]mexpr,\[CapitalDelta]Expr,\[CapitalDelta]listArray,myqSec},
(* split the qPart into three factors: q\[Mu]lsit, \[CapitalDelta]list, and "coeff" which is the product of the rest *)
q\[Mu]list=Cases[qPart,Subscript[q, \[Mu]_]->\[Mu]];
\[CapitalDelta]list=Cases[qPart,Subscript[\[CapitalDelta], __]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(__\), \(__\)]\)|Subscript[m, __]|\!\(\*SubsuperscriptBox[\(m\), \(__\), \(__\)]\)];
coeff=Times@@DeleteCases[qPart,Subscript[q, __]|Subscript[\[CapitalDelta], __]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(__\), \(__\)]\)|Subscript[m, __]|\!\(\*SubsuperscriptBox[\(m\), \(__\), \(__\)]\)];
(* convert q\[Mu]lsit into Subscript[\[CapitalDelta], 0], Subscript[\[Eta], \[Mu]\[Nu]], and Subscript[cp, n]=1/(d(d+2)...(d+2n-2)) for n pair of Subscript[q, \[Mu]] *)
npair=Length[q\[Mu]list]/2;
\[CapitalDelta]list=Join[\[CapitalDelta]list,{\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(-npair\)]\)}];
\[Eta]listArray=((Subscript[\[Eta],#]&/@#)/.{\!\(\*SubscriptBox[\(\[Eta]\), \({a__}\)]\)->Subscript[\[Eta], a]})&/@AllPairings[q\[Mu]list];
(* expand and truncate \[CapitalDelta]Part expression according to the given Heavylist and desired LightOrd *)
Mpattern=Alternatives@@(Join@@({Subscript[m, #],\!\(\*SubsuperscriptBox[\(m\), \(#\), \(__\)]\),Subscript[\[CapitalDelta], #],\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(#\), \(__\)]\)}&/@Heavylist));
\[CapitalDelta]Mexpr=Times@@Cases[\[CapitalDelta]list,Mpattern];
\[CapitalDelta]mexpr=Times@@(DeleteCases[\[CapitalDelta]list,Mpattern]/.{Subscript[\[CapitalDelta], i_]:>If[i==0,Subscript[\[CapitalDelta], i],Subscript[\[CapitalDelta], 0] 1/(1-Subscript[\[CapitalDelta], 0] \!\(\*SubsuperscriptBox[\(m\), \(i\), \(2\)]\))]});
\[CapitalDelta]Expr=Expand[\[CapitalDelta]Mexpr*(Normal[Series[\[CapitalDelta]mexpr/.{Subscript[m, i_]->Subscript[m, i]\[Epsilon]},{\[Epsilon],0,LightOrd}]]/.{\[Epsilon]->1})];
(* combine coeff, Subscript[cp, npair], and the truncated \[CapitalDelta]Part expression into the new qSec *)
\[CapitalDelta]listArray=Flatten[{#/.{Times->List}}]&/@Flatten[{\[CapitalDelta]Expr/.{Plus->List}}];
myqSec=Join[{coeff,Subscript[cp, npair]},#]&/@(Flatten/@Tuples[{\[Eta]listArray,\[CapitalDelta]listArray}]);
Return[myqSec];
];

(* Symmetrize a qSec and expand in hard region before performing the q integral *)
SymHardqSec[qSec_,Heavylist_,LightOrd_]:=Module[{myqSec},
myqSec=Join@@(SymHardqPart[#,Heavylist,LightOrd]&/@qSec);
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];

(* Carry out the q integral for a qPart *)
IntegrateqPart[qPart_]:=Module[{coeff,\[CapitalDelta]list,r,nlist,masslist,LoopIparameters,myqPart},
coeff=Times@@DeleteCases[qPart,Subscript[\[CapitalDelta], __]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(__\), \(__\)]\)];
(* Subscript[cp, n]=1/(d(d+2)...(d+2n-2)) for n pair of Subscript[q, \[Mu]] *)
coeff=coeff/.{Subscript[cp, n_]:>Times@@(1/(d+2#-2)&/@Range[n])};
\[CapitalDelta]list=Cases[qPart,Subscript[\[CapitalDelta], __]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(__\), \(__\)]\)];
r=-Plus@@(Cases[\[CapitalDelta]list,Subscript[\[CapitalDelta], 0]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(__\)]\)]/.{Subscript[\[CapitalDelta], 0]->1,\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(a_\)] -> a\)});
LoopIparameters=Transpose[DeleteCases[\[CapitalDelta]list,Subscript[\[CapitalDelta], 0]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(__\)]\)]/.{Subscript[\[CapitalDelta], imass_]->{imass,1},\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(imass_\), \(n_\)] -> \({imass, n}\)\)}];
masslist=Subscript[m, #]&/@LoopIparameters[[1]];
nlist=LoopIparameters[[2]];
If[Length[nlist]<3,
	(* store the result as {result}, when there are two or less heavy masses *)
	myqPart={LoopInt[r,nlist,masslist,coeff]},
	(* store the result as {coeff, LoopI}, when there are three or more heavy masses *)
	myqPart={coeff,LoopInt[r,nlist,masslist,1]};
];
Return[myqPart];
];

(* Carry out the q integral for a qSec *)
IntegrateqSec[qSec_]:=Module[{len,myqSec},
myqSec=IntegrateqPart/@qSec;
If[myqSec==={},myqSec={{0}}];
If[Length[myqSec[[1]]]<2,myqSec={{Simplify[Plus@@Flatten[myqSec]]}}];
Return[myqSec];
];


(* ::Subsection:: *)
(*Polynomial Manipulations*)


(* ::Text::Closed:: *)
(*Descriptions*)


(* ::Input::Initialization:: *)
(*
"poly" and "term" are used to handle the CDE procedure;

A "poly" is a list of "terms", while a "term" consists of three lists
term={qSec, Oper, Ord};
for example
UCDEDim[4]\[LeftDoubleBracket]1\[RightDoubleBracket]={{{1/6,Subscript[dq, Subscript[\[Mu], 1]],Subscript[dq, Subscript[\[Mu], 2]],Subscript[dq, Subscript[\[Mu], 3]]}},{{Subscript[P, Subscript[\[Mu], 1]],Subscript[P, Subscript[\[Mu], 2]],Subscript[P, Subscript[\[Mu], 3]],U}},{4,3,0}};
  GCDEDim[{Subscript[\[Nu], 1],Subscript[\[Nu], 2]},4]\[LeftDoubleBracket]1\[RightDoubleBracket]={{{1/8,Subscript[dq, Subscript[\[Mu], 1]],Subscript[dq, Subscript[\[Mu], 2]]}},{{Subscript[P, Subscript[\[Mu], 1]],Subscript[P, Subscript[\[Mu], 2]],Subscript[G, Subscript[\[Nu], 1],Subscript[\[Nu], 2]]}},{4,2,2}};
The first list "qSec" is the q-Section of the term. This part will be integrated over eventually;
The second list "Oper" stores the effective operator. This part will be shown in the final result;The third list "Ord" is a list of auxiliary parameters
Ord={dim, ndummy, nopen};
with the following meaning respectively;
dim      the operator dimension;
ndummy   the number of dummy Lorentz index pairs (Subscript[\[Mu], i] indices);
nopen    the number of open Lorentz indices;

The numbers of Lorentz indices, "ndummy" and "nopen", are only used in the steps of generating the CDE poly;
Once we obtain the poly and move on to address the loop integral (see the main function SuperTrace[] below), they will no longer be in use. In the final output, they will be discarded, and only "dim" will be kept.
*)


(* ::Subsubsection::Closed:: *)
(*Term and Poly Arithmetic*)


(* ::Input::Initialization:: *)
Clear[SimplifyOperTerm];
Clear[SimplifyPoly];
Clear[ScaleTerm];
Clear[ScalePoly];
Clear[SumPolys];
Clear[ShiftDummyIndicesTerm];
Clear[ShiftDummyIndicesPoly];
Clear[DistinguishDummyIndices];
Clear[MultiplyTerms];
Clear[MultiplyPolys];
Clear[ContractTermIndices];
Clear[ContractPolyIndices];


(* ::Input::Initialization:: *)
(* Move all commuting factors, such as constants, Subscript[m, i], and Subscript[\[Eta], \[Mu]\[Nu]] in Oper to qSec *)
SimplifyOperTerm[term_]:=Module[{myqSec,coeffOper,myOper,myterm},
myOper=term[[2]];
coeffOper=Times@@Flatten[Cases[#,_?NumericQ|Subscript[m, __]|Subscript[\[Eta], __]]&/@myOper];
myOper=DeleteCases[#,_?NumericQ|Subscript[m, __]|Subscript[\[Eta], __]]&/@myOper;
myOper=Select[myOper,(#=!={})&];
myqSec=ScaleqSec[term[[1]],coeffOper];
myterm=ReplacePart[term,{1->myqSec,2->myOper}];
Return[myterm];
];

(* Simplify a poly by collecting and simplifying its terms *)
SimplifyPoly[poly_]:=Module[{mypoly},
mypoly=SimplifyOperTerm/@poly;
mypoly=ReplacePart[#[[1]],1->Join@@(#[[1]]&/@#)]&/@GatherBy[mypoly,#[[2]]&];
mypoly=ReplacePart[#,1->SimplifyqSec[#[[1]]]]&/@mypoly;
mypoly=Select[mypoly,#[[1]]=!={{0}}&];
mypoly=SortBy[mypoly,#[[3]][[1]]&];
Return[mypoly];
];

(* Scale a term by a constant coeff, which does not depend on q or dq *)
ScaleTerm[term_,coeff_]:=Module[{myqSec,myterm},
myqSec=ScaleqSec[term[[1]],coeff];
myterm=ReplacePart[term,1->myqSec];
Return[myterm];
];

(* Scale a poly by a constant coeff, which does not depend on q or dq *)
ScalePoly[poly_,coeff_]:=Module[{mypoly},
mypoly=ScaleTerm[#,coeff]&/@poly;
Return[mypoly];
];

(* Sum a list of polys into a poly *)
SumPolys[polylist_]:=Module[{mypoly},
mypoly=Join@@polylist;
mypoly=SimplifyPoly[mypoly];
Return[mypoly];
];

(* Shift all the dummy indices (Subscript[\[Mu], i] indices) in a term by n *)
ShiftDummyIndicesTerm[term_,n_]:=Module[{myterm},
myterm=term/.{Subscript[\[Mu], m_]->Subscript[\[Mu], m+n]};
Return[myterm];
];

(* Shift all the dummy indices (Subscript[\[Mu], i] indices) in a poly by n *)
ShiftDummyIndicesPoly[poly_,n_]:=Module[{mypoly},
mypoly=ShiftDummyIndicesTerm[#,n]&/@poly;
Return[mypoly];
];

(* Before multiplying a list of terms, distinguish their dummy indices by shifting the ones appearing later *)
DistinguishDummyIndices[termlist_]:=Module[{shiftlist,mytermlist},
shiftlist=Join[{0},Accumulate[((#[[3]][[2]])&/@termlist)[[;;-2]]]];
mytermlist=MapThread[ShiftDummyIndicesTerm[#1,#2]&,{termlist,shiftlist}];
Return[mytermlist];
];

(* Multiply a list of terms into a term *)
MultiplyTerms[termlist_]:=Module[{mytermlist,qSec,Oper,Ord,myterm},
mytermlist=DistinguishDummyIndices[termlist];
qSec=MultiplyqSecs[#[[1]]&/@mytermlist];
Oper=Join@@(#[[2]]&/@mytermlist);
Ord=Plus@@(#[[3]]&/@mytermlist);
myterm={qSec,Oper,Ord};
Return[myterm];
];

(* Multiply a list of polys into a poly *)
MultiplyPolys[polylist_]:=Module[{mypoly},
mypoly=MultiplyTerms[#]&/@Tuples[polylist];
mypoly=SimplifyPoly[mypoly];
Return[mypoly];
];

(* Detect Lorentz index pairs of the type in \[Nu]list in a term, and rewrite them into Subscript[\[Mu], i] pairs *)
ContractTermIndices[term_,\[Nu]list_]:=Module[{my\[Nu]list,mylist,n\[Mu],nOpen,indices,dummylist,ndummy,rules,myterm},
my\[Nu]list=\[Nu]list;
(* if \[Nu]list contains "\[Mu]", remove it *)
If[MemberQ[my\[Nu]list,\[Mu]],
Print["ContractTermIndices[] called with invalid input \[Nu]list=",my\[Nu]list];
Print["\[Mu] is reserved for default dummy indices, and need not be further contracted."];
my\[Nu]list=DeleteCases[my\[Nu]list,\[Mu]];
Print["Proceeding with \[Nu]list=",my\[Nu]list];
];
(* Put qSec\[LeftDoubleBracket]1\[RightDoubleBracket] and Oper together to find dummy indices to contract *)
mylist=Join[term[[1]][[1]],Flatten[term[[2]]]];
n\[Mu]=term[[3]][[2]];
nOpen=term[[3]][[3]];
indices=Tuples[{my\[Nu]list,Range[0,nOpen]}];
dummylist=Join@@(If[Count[mylist,Subscript[#[[1]], #[[2]]],All]==2,{Subscript[#[[1]], #[[2]]]},{}]&/@indices);
ndummy=Length[dummylist];
rules=MapThread[#1->Subscript[\[Mu], n\[Mu]+#2]&,{dummylist,Range[ndummy]}];
myterm=term/.rules;
myterm[[3]][[2]]=n\[Mu]+ndummy;
myterm[[3]][[3]]=nOpen-2ndummy;
Return[myterm];
];

(* Detect Lorentz index pairs of the type in \[Nu]list in a poly, and rewrite them into Subscript[\[Mu], i] pairs *)
ContractPolyIndices[poly_,\[Nu]list_]:=Module[{my\[Nu]list,mypoly},
my\[Nu]list=\[Nu]list;
(* if \[Nu]list contains "\[Mu]", remove it *)
If[MemberQ[my\[Nu]list,\[Mu]],
Print["ContractTermIndices[] called with invalid input \[Nu]list=",my\[Nu]list];
Print["\[Mu] is reserved for default dummy indices, and need not be further contracted."];
my\[Nu]list=DeleteCases[my\[Nu]list,\[Mu]];
Print["Proceeding with \[Nu]list=",my\[Nu]list];
];
mypoly=ContractTermIndices[#,my\[Nu]list]&/@poly;
Return[mypoly];
];


(* ::Subsubsection::Closed:: *)
(*Trimmings*)


(* ::Input::Initialization:: *)
Clear[qPartFVanish];
Clear[FTrimqSec];
Clear[FTrimTerm];
Clear[FTrimPoly];
Clear[qEvenTrimTerm];
Clear[qEvenTrimPoly];

Clear[\[Eta]pairTerm];
Clear[Contract\[Eta]Term];
Clear[IBPTerm];
Clear[IBPPoly];
Clear[IBPAllTerm];
Clear[IBPAllPoly];
Clear[PPFpattern0];
Clear[PPFpattern1];
Clear[PPFrules1];
Clear[PPFOrgTerm];
Clear[FIndexOrgOper];
Clear[OperIndexOrgTerm];

Clear[All\[Gamma]Pairings];
Clear[Trace\[Gamma]Term];


(* ::Input::Initialization:: *)
(* Check if a qPart vanishes upon contracting with a given Subscript[F, \[Mu]\[Nu]] *)
qPartFVanish[qPart_,F\[Mu]pair_]:=Module[{myqPartSplit,q\[Mu]listArray,dq\[Mu]listArray,\[Eta]\[Mu]pairlist},
myqPartSplit=SplitqPart[qPart];
(* check if qPart vanishes due to Subscript[q, \[Mu]]Subscript[q, \[Nu]] *)
q\[Mu]listArray=Cases[#,Subscript[q, sub__]->sub]&/@myqPartSplit;
If[Or@@(SubsetQ[#,F\[Mu]pair]&/@q\[Mu]listArray),Return[True]];
(* check if qPart vanishes due to Subscript[dq, \[Mu]]Subscript[dq, \[Nu]] *)
dq\[Mu]listArray=Cases[#,Subscript[dq, sub__]->sub]&/@myqPartSplit;
If[Or@@(SubsetQ[#,F\[Mu]pair]&/@dq\[Mu]listArray),Return[True]];
(* check if qPart vanishes due to Subscript[\[Eta], \[Mu]\[Nu]] *)
\[Eta]\[Mu]pairlist=Cases[qPart,Subscript[\[Eta], sub__]->{sub}];
If[MemberQ[\[Eta]\[Mu]pairlist,F\[Mu]pair]||MemberQ[\[Eta]\[Mu]pairlist,Reverse[F\[Mu]pair]],Return[True]];
Return[False];
];

(* FTrim a qSec *)
FTrimqSec[qSec_,F\[Mu]pair_]:=Module[{myqSec},
myqSec=Select[qSec,!qPartFVanish[#,F\[Mu]pair]&];
myqSec=If[myqSec==={},{{0}},myqSec];
Return[myqSec];
];

(* FTrim a term *)
FTrimTerm[term_]:=Module[{F\[Mu]pairlist,myqSec,myterm},
F\[Mu]pairlist=Cases[Flatten[term[[2]]],Subscript[F, a__]->{a}];
myqSec=Fold[FTrimqSec,term[[1]],F\[Mu]pairlist];
myterm=ReplacePart[term,1->myqSec];
Return[myterm];
];

(* FTrim a poly *)
FTrimPoly[poly_]:=Module[{mypoly},
mypoly=FTrimTerm/@poly;
mypoly=Select[mypoly,#[[1]]=!={{0}}&];
Return[mypoly];
];

(* Trim a term by keeping only even parts under q\[Rule]-q *)
qEvenTrimTerm[term_]:=Module[{myqSec,myterm},
myqSec=qEvenTrimqSec[term[[1]]];
myterm=ReplacePart[term,1->myqSec];
Return[myterm];
];

(* Trim a poly by keeping only even parts under q\[Rule]-q *)
qEvenTrimPoly[poly_]:=Module[{mypoly},
mypoly=qEvenTrimTerm/@poly;
mypoly=Select[mypoly,#[[1]]=!={{0}}&];
Return[mypoly];
];

(* Contract a term with an Subscript[\[Eta], \[Mu]\[Nu]] *)
\[Eta]pairTerm[term_,\[Eta]pair_]:=Module[{myOper,myterm},
myOper=term[[2]];
If[Count[myOper,\[Eta]pair[[2]],All]==1,
myOper=myOper/.{\[Eta]pair[[2]]->\[Eta]pair[[1]]},
If[Count[myOper,\[Eta]pair[[1]],All]==1,
myOper=myOper/.{\[Eta]pair[[1]]->\[Eta]pair[[2]]},
myOper=Join[{{Subscript[\[Eta], \[Eta]pair]}},myOper]/.{\!\(\*SubscriptBox[\(\[Eta]\), \({a__}\)]\)->Subscript[\[Eta], a]};
];
];
myterm=ReplacePart[term,2->myOper];
Return[myterm];
];

(* Contract all Subscript[\[Eta], \[Mu]\[Nu]] in the qSec of a term with its Oper to get a poly *)
Contract\[Eta]Term[term_]:=Module[{myqSec,\[Eta]pairsArray,mypoly},
myqSec=term[[1]];
mypoly=ReplacePart[term,1->#]&/@({DeleteCases[#,Subscript[\[Eta], __]]}&/@myqSec);
\[Eta]pairsArray=Cases[#,Subscript[\[Eta], a__]->{a}]&/@myqSec;
mypoly=MapThread[Fold[\[Eta]pairTerm,#1,#2]&,{mypoly,\[Eta]pairsArray}];
Return[mypoly];
];

(* Use IBP on a term to remove one Subscript[P, \[Mu]] on the last factor in Oper to get a poly *)
IBPTerm[term_]:=Module[{myOper,len,myOperArray,mypoly},
myOper=term[[2]];
len=Length[myOper];
If[len<2,Return[{term}]];
If[!MatchQ[myOper[[-1]][[1]],Subscript[P, __]],Return[{term}]];
myOperArray=ReplacePart[myOper,{#->Join[{-1, myOper[[-1]][[1]]},myOper[[#]]],-1->Delete[myOper[[-1]],1]}]&/@Range[len-1];
mypoly=ReplacePart[term,2->#]&/@myOperArray;
Return[mypoly];
];

(* Use IBP on a poly to remove one Subscript[P, \[Mu]] on the last factor in Oper *)
IBPPoly[poly_]:=Module[{mypoly},
mypoly=Join@@(IBPTerm/@poly);
Return[mypoly];
];

(* Use IBP on a term to remove all Subscript[P, \[Mu]] on the last factor in Oper to get a poly *)
IBPAllTerm[term_]:=Module[{nIBP,mypoly},
nIBP=Count[term[[2]][[-1]],Subscript[P, __]];
mypoly={term};
mypoly=Nest[IBPPoly,mypoly,nIBP];
Return[mypoly];
];

(* Use IBP on a poly to move all Subscript[P, \[Mu]] on the last factor in Oper *)
IBPAllPoly[poly_]:=Module[{mypoly},
mypoly=Join@@(IBPAllTerm/@poly);
Return[mypoly];
];

(* PPF paterns and their simplification rules *)
PPFpattern0=Alternatives@@{{Subscript[P, \[Mu]_],Subscript[P, \[Nu]_],Subscript[F, \[Mu]_,\[Nu]_]},{__,Subscript[P, \[Mu]_],Subscript[P, \[Nu]_],Subscript[F, \[Mu]_,\[Nu]_]},{Subscript[P, \[Mu]_],Subscript[P, \[Nu]_],Subscript[F, \[Nu]_,\[Mu]_]},{__,Subscript[P, \[Mu]_],Subscript[P, \[Nu]_],Subscript[F, \[Nu]_,\[Mu]_]}};
PPFpattern1=Alternatives@@{{Subscript[P, \[Rho]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]},{__,Subscript[P, \[Rho]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]},{Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]},{__,Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]},{Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Nu]_,\[Mu]_]},{__,Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Nu]_,\[Mu]_]}};
PPFrules1={{Subscript[P, \[Rho]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]}->{{Subscript[P, \[Mu]],Subscript[P, \[Rho]],Subscript[F, \[Rho],\[Nu]]},{I,Subscript[F, \[Rho],\[Mu]],Subscript[F, \[Rho],\[Nu]]},{-1,Subscript[P, \[Nu]],Subscript[P, \[Rho]],Subscript[F, \[Rho],\[Mu]]},{-I,Subscript[F, \[Rho],\[Nu]],Subscript[F, \[Rho],\[Mu]]}},
{a__,Subscript[P, \[Rho]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]}->{{a,Subscript[P, \[Mu]],Subscript[P, \[Rho]],Subscript[F, \[Rho],\[Nu]]},{a,I,Subscript[F, \[Rho],\[Mu]],Subscript[F, \[Rho],\[Nu]]},{a,-1,Subscript[P, \[Nu]],Subscript[P, \[Rho]],Subscript[F, \[Rho],\[Mu]]},{a,-I,Subscript[F, \[Rho],\[Nu]],Subscript[F, \[Rho],\[Mu]]}},
{Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]}->{{Subscript[P, \[Rho]],Subscript[P, \[Mu]],Subscript[F, \[Mu],\[Nu]]},{I,Subscript[F, \[Mu],\[Rho]],Subscript[F, \[Mu],\[Nu]]}},{a__,Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Nu]_,\[Mu]_]}->{{a,Subscript[P, \[Rho]],Subscript[P, \[Mu]],Subscript[F, \[Nu],\[Mu]]},{a,I,Subscript[F, \[Mu],\[Rho]],Subscript[F, \[Nu],\[Mu]]}},
{Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Nu]_,\[Mu]_]}->{{Subscript[P, \[Rho]],Subscript[P, \[Mu]],Subscript[F, \[Nu],\[Mu]]},{I,Subscript[F, \[Mu],\[Rho]],Subscript[F, \[Nu],\[Mu]]}},{a__,Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]}->{{a,Subscript[P, \[Rho]],Subscript[P, \[Mu]],Subscript[F, \[Mu],\[Nu]]},{a,I,Subscript[F, \[Mu],\[Rho]],Subscript[F, \[Mu],\[Nu]]}}};

(* Use PPF simplification rules on a term to get a poly *)
PPFOrgTerm[term_]:=Module[{operArray,mypoly},
If[Count[term[[2]],PPFpattern0]!= 0,Return[{}]];
operArray=Tuples[(If[MatchQ[#,PPFpattern1],#,{#}]&/@term[[2]])/.PPFrules1];
mypoly=ReplacePart[term,2->#]&/@operArray;
Return[mypoly];
];

(* Organize the indices of the nth Subscript[F, \[Mu]\[Nu]] in an Oper *)
FIndexOrgOper[oper_,n_]:=Module[{mylist,partNolist,partNo,\[Mu]pair,indices,dummyindices,\[Mu]pairother,myOper},
mylist=Flatten[oper];
partNolist=Join@@(Tuples[{{#},Range[Length[oper[[#]]]]}]&/@Range[Length[oper]]);
partNo=Cases[partNolist,_?(MatchQ[oper[[#[[1]]]][[#[[2]]]],Subscript[F, __]]&)][[n]];
\[Mu]pair=Cases[mylist,Subscript[F, a__]->{a}][[n]];
indices=DeleteCases[Cases[mylist,Subscript[_, a__]->a],_?NumericQ];
dummyindices=DeleteDuplicates[Select[indices,Count[indices,#]>1&]];
(* If \[Mu]pair are not both dummy indices, put indices in Subscript[F, \[Mu]\[Nu]] in canonical order using its antisymmetry *)
If[!SubsetQ[dummyindices,\[Mu]pair],
If[Sort[\[Mu]pair]===\[Mu]pair,Return[oper]];
myOper=Flatten/@(ReplacePart[oper,partNo->{-1,Subscript[F, Reverse[\[Mu]pair]]}]/.{\!\(\*SubscriptBox[\(F\), \({a__}\)]\)->Subscript[F, a]});
Return[myOper];
];
(* If \[Mu]pair are both dummy indices, canonically order both dummy indices *)
\[Mu]pairother=Cases[Cases[Flatten[Delete[oper,partNo]],Subscript[_, a__]->a],_?(MemberQ[\[Mu]pair,#]&)];
If[\[Mu]pair===\[Mu]pairother,Return[oper]];
If[Sort[\[Mu]pair]=!=\[Mu]pair,
myOper=Flatten/@(ReplacePart[oper,partNo->{-1,Subscript[F, Reverse[\[Mu]pair]]}]/.{\!\(\*SubscriptBox[\(F\), \({a__}\)]\)->Subscript[F, a]});
Return[myOper];
];
myOper=Flatten/@(ReplacePart[oper,partNo->{-1,Subscript[F, Reverse[\[Mu]pair]]}]/.{\!\(\*SubscriptBox[\(F\), \({a__}\)]\)->Subscript[F, a]});
myOper=myOper/.{\[Mu]pair[[1]]->\[Mu]pair[[2]],\[Mu]pair[[2]]->\[Mu]pair[[1]]};
Return[myOper];
];

(* Organize the indices of Oper in a term *)
OperIndexOrgTerm[term_]:=Module[{myOper,indices,dummyindices,openindices,Fpairs,ndummy,nopen,nF,myterm},
myOper=term[[2]];
(* extract indices in Oper *)
indices=DeleteCases[Cases[Flatten[myOper],Subscript[_, a__]->a],_?NumericQ];
dummyindices=DeleteDuplicates[Select[indices,Count[indices,#]>1&]];
openindices=DeleteCases[indices,_?(Count[indices,#]>1&)];
ndummy=Length[dummyindices];
nopen=Length[openindices];
If[Cases[openindices,Subscript[\[Mu], _]]=!={},
Print["OperIndexOrgTerm called with open indices containing \!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\)."];
Print["open indices=",openindices];
Print["term=",term];
Print["Aborted."];
Abort[];
];
(* canonically order dummy indices *)
myterm=term/.MapThread[#1->Subscript[\[Mu], #2]&,{dummyindices,Range[ndummy]}];
(* canonically order Subscript[F, \[Mu]\[Nu]] indices *)
myOper=myterm[[2]];
nF=Count[myOper,Subscript[F, __],All];
myOper=Fold[FIndexOrgOper,myOper,Range[nF]];
myterm=ReplacePart[myterm,2->myOper];
Return[myterm];
];

(* Get the \[Eta]expr from all \[Gamma] pairings (alternating pairings) of an even number of indices *)
All\[Gamma]Pairings[{}]:=1;
All\[Gamma]Pairings[{a_,b_}]:=Subscript[\[Eta], a,b];
All\[Gamma]Pairings[{a_,b__}]:=Sum[(-1)^(k-1) Subscript[\[Eta], a,{b}[[k]]]All\[Gamma]Pairings[Delete[{b},k]],{k,Length[{b}]}];

(* Simplify a term to get a poly when the Ulist has no \[Gamma] dependence *)
Trace\[Gamma]Term[term_]:=Module[{myOper,n\[Mu],\[Mu]starts,coeff,\[Gamma]\[Mu]list,\[Eta]expr,\[Eta]pairArray,coeffArray,mypoly},
myOper=term[[2]];
(* replace \[Sigma]F with Subscript[\[ImaginaryI]\[Gamma], \[Mu]]Subscript[\[Gamma], \[Nu]]Subscript[F, \[Mu]\[Nu]] *)
n\[Mu]=Max[Join[{0},Cases[Cases[Flatten[myOper],Subscript[_, a__]->a],Subscript[\[Mu], b_]->b]]];
\[Mu]starts=n\[Mu]+2*Join[{0},Accumulate[Count[#,\[Sigma]F]&/@myOper][[;;-2]]];
myOper=Flatten/@MapThread[#1/.{\[Sigma]F->{I,Subscript[\[Gamma], Subscript[\[Mu], #2+1]],Subscript[\[Gamma], Subscript[\[Mu], #2+2]],Subscript[F, Subscript[\[Mu], #2+1],Subscript[\[Mu], #2+2]]}}&,{myOper,\[Mu]starts}];
(* extract constants and \[Gamma], and carry out trace of \[Gamma] *)
coeff=Times@@Cases[Flatten[myOper],_?NumericQ];
\[Gamma]\[Mu]list=Cases[Cases[Flatten[myOper],Subscript[\[Gamma], __]],Subscript[_, a__]->a];
\[Eta]expr=coeff All\[Gamma]Pairings[\[Gamma]\[Mu]list]/.{Subscript[\[Eta], \[Mu]_,\[Mu]_]->d};
\[Eta]pairArray=(Flatten[{#/.{Times->List}}])&/@Flatten[{\[Eta]expr/.{Plus->List}}];
(* multiply \[Eta]expr with Oper to get a poly *)
coeffArray=(Times@@Cases[#,_?NumericQ|d])&/@\[Eta]pairArray;
myOper=DeleteCases[#,_?NumericQ|Subscript[\[Gamma], __]]&/@myOper;
mypoly=ReplacePart[term,{1->ScaleqSec[term[[1]],#],2->myOper}]&/@coeffArray;
\[Eta]pairArray=Cases[DeleteCases[#,_?NumericQ|d],Subscript[\[Eta], a__]->{a}]&/@\[Eta]pairArray;
mypoly=MapThread[Fold[\[Eta]pairTerm,#1,#2]&,{mypoly,\[Eta]pairArray}];
Return[mypoly];
];


(* ::Subsubsection::Closed:: *)
(*Derivatives and Integrals*)


(* ::Input::Initialization:: *)
Clear[dqAllPoly];
Clear[SymHardTerm];
Clear[SymHardPoly];
Clear[IntegratePoly];


(* ::Input::Initialization:: *)
(* Carrying out all the dq derivatives in a poly *)
dqAllPoly[poly_]:=Module[{mypoly},
mypoly=ReplacePart[#,1->dqAllqSec[#[[1]]]]&/@poly;
Return[mypoly];
];

(* Symmetrize a term and expand in hard region to get a poly before performing the q integral *)
SymHardTerm[term_,dim_,Heavylist_,SoftOrd_]:=Module[{myqSec,myexprArray,\[Eta]pairsArray,myterm,mypoly},
(* contract all the Lorentz indices in qSec *)
myqSec=term[[1]];
myexprArray=(((Times@@#)//.\[Eta]ContractionRules)/.qContractionRules)&/@myqSec;
myexprArray=myexprArray/.{Subscript[\[Eta], \[Mu]_,\[Nu]_]:>Subscript[\[Eta], Sort[{\[Mu],\[Nu]}]]}/.{\!\(\*SubscriptBox[\(\[Eta]\), \({a__}\)]\)->Subscript[\[Eta], a]};
myqSec=qPartFromExpr[#]&/@myexprArray;
(* FTrim the qSec *)
myqSec=FTrimTerm[ReplacePart[term,1->myqSec]][[1]];
If[myqSec==={{0}},Return[{}]];
(* symmetrize and expand in hard region *)
myqSec=SymHardqSec[myqSec,Heavylist,dim-term[[3]][[1]]+SoftOrd];
myterm=ReplacePart[term,1->myqSec];
mypoly=Contract\[Eta]Term[myterm];
Return[mypoly];
];

(* Symmetrize a poly, expand in hard region, and organize it before performing the q integral *)
SymHardPoly[poly_,dim_,Heavylist_,SoftOrd_,No\[Gamma]inU_]:=Module[{mypoly},
mypoly=Join@@(SymHardTerm[#,dim,Heavylist,SoftOrd]&/@poly);
mypoly=IBPAllPoly[mypoly];
(* Simplify the result when Ulist has no \[Gamma] dependence *)
If[No\[Gamma]inU,
(* delete terms with odd numbers of Subscript[\[Gamma], \[Mu]] or only one \[Sigma]F *)
mypoly=Select[mypoly,EvenQ[Count[#[[2]],Subscript[\[Gamma], __],All]]&];
mypoly=Select[mypoly,!((Count[#[[2]],Subscript[\[Gamma], __],All]==0)&&(Count[#[[2]],\[Sigma]F,All]==1))&];
(* carry out trace of \[Gamma] *)
mypoly=Join@@(Trace\[Gamma]Term/@mypoly);
mypoly=Select[mypoly,Count[#[[2]],{Subscript[F, \[Mu]_,\[Mu]_]}|{__,Subscript[F, \[Mu]_,\[Mu]_]}]==0&];
];
(* organize and simplify *)
mypoly=OperIndexOrgTerm/@mypoly;
mypoly=SimplifyPoly[mypoly];
mypoly=Join@@(PPFOrgTerm/@mypoly);
mypoly=OperIndexOrgTerm/@mypoly;
mypoly=SimplifyPoly[mypoly];
Return[mypoly];
];

(* Carrying out the q integral of a poly *)
IntegratePoly[poly_]:=Module[{mypoly},
mypoly=ReplacePart[#,1->IntegrateqSec[#[[1]]]]&/@poly;
mypoly=Select[mypoly,#[[1]]=!={{0}}&];
Return[mypoly];
];


(* ::Subsection:: *)
(*CDE Quantities*)


(* ::Text::Closed:: *)
(*Descriptions*)


(* ::Input::Initialization:: *)
(*
The CDE quantities are defined below;

\!\(
\*SubsuperscriptBox[\(U\), \(i\), \(CDE\)] = \(\(
\*SubsuperscriptBox[\(\[Sum]\), \(n = 0\), \(\[Infinity]\)]
\*FractionBox[\(1\), \(n!\)]\((\(
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(n\)]]
\*SubscriptBox[\(U\), \(i\)])\)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(n\)]]\)\);

\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(i\)]
\*SubscriptBox[\(\[Nu]\), \(j\)]\), \(CDE\)] = \(\(\(-i\)\(
\*SubsuperscriptBox[\(\[Sum]\), \(n = 0\), \(\[Infinity]\)]
\*FractionBox[\(n + 1\), \(\((n + 2)\)!\)]\((\(
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(n\)]]
\*SubscriptBox[\(F\), \(
\*SubscriptBox[\(\[Nu]\), \(i\)]
\*SubscriptBox[\(\[Nu]\), \(j\)]\)])\)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(1\)]]\) ... \)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(n\)]]\)\);

\!\(
\*SubsuperscriptBox[\(P\), 
SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)] = \(\(-
\*SubscriptBox[\(q\), 
SubscriptBox[\(\[Nu]\), \(1\)]]\) + 
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(2\)]]\)\);

X^CDE=(Subscript[q, Subscript[\[Nu], 1]] Subsuperscript[G, Subscript[\[Nu], 1]Subscript[\[Nu], 2], CDE] + \!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]\ 
\*SubscriptBox[\(q\), 
SubscriptBox[\(\[Nu]\), \(1\)]]\))Subscript[dq, Subscript[\[Nu], 2]] - \!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]\ 
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(3\)]\), \(CDE\)]\ 
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(2\)]]\ 
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(3\)]]\);

\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)] = \(
\*FractionBox[\(1\), \(
\*SuperscriptBox[\(q\), \(2\)] - 
\*SubsuperscriptBox[\(m\), \(i\), \(2\)] - 
\*SuperscriptBox[\(X\), \(CDE\)]\)] = \(\(
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)] + 
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)]
\*SuperscriptBox[\(X\), \(CDE\)]
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)] + 
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)]
\*SuperscriptBox[\(X\), \(CDE\)]
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)]
\*SuperscriptBox[\(X\), \(CDE\)]
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)] +  ... \)\ \ \ with\ 
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)] = 
\*FractionBox[\(1\), \(
\*SuperscriptBox[\(q\), \(2\)] - 
\*SubsuperscriptBox[\(m\), \(i\), \(2\)]\)]\)\)\);
*)


(* ::Subsubsection::Closed:: *)
(*\!\(\*SubsuperscriptBox[\(U\), \(i\), \(CDE\)]\) and \!\(\*SubsuperscriptBox[\(G\), \(\[Mu]\[Nu]\), \(CDE\)]\)*)


(* ::Input::Initialization:: *)
Clear[UCDEDim];
Clear[GCDEDim];


(* ::Input::Initialization:: *)
(* Generate the poly Subsuperscript[U, i, CDE] at a given operator dimension *)
UCDEDim[dim_,OptionsPattern[{Udim->1,Uoper->{}}]]:=Module[{Uexpr,n,coeff,UArray,qSec,OperArray,OrdArray,mypoly},
Uexpr=OptionValue[Uoper];
Uexpr=If[Uexpr==={},U,Uexpr];
If[Uexpr===1,If[dim==0,Return[{{{{1}},{},{0,0,0}}}],Return[{}]]];
n=dim-OptionValue[Udim];
If[(!IntegerQ[n])||(n<0),Return[{}]];
coeff=1/n!;
qSec={Join[{coeff},Subscript[dq,Subscript[\[Mu],#]]&/@Range[1,n]]};
UArray=Flatten[{(#/.{Times->List,NonCommutativeMultiply->List})}]&/@Flatten[{(Uexpr/.Plus->List)}];
OrdArray={dim,n,Length[DeleteCases[Flatten[Cases[#,Subscript[__, a__]->{a}]],_?NumericQ]]}&/@UArray;
OperArray={Join[Subscript[P,Subscript[\[Mu],#]]&/@Range[n],#]}&/@UArray;
mypoly=MapThread[{qSec,#1,#2}&,{OperArray,OrdArray}];
mypoly=SimplifyPoly[mypoly];
Return[mypoly];
];

(* Generate the poly Subsuperscript[G, Subscript[\[Nu], i]Subscript[\[Nu], j], CDE] at a given operator dimension *)
GCDEDim[{\[Nu]i_,\[Nu]j_},dim_]:=Module[{n,coeff,expr,qSec,Oper,Ord,mypoly},
(* Abort if {\[Nu]i, \[Nu]j} contiains Subscript[\[Mu], __] *)
If[MemberQ[{\[Nu]i,\[Nu]j},Subscript[\[Mu], _]],
Print["GCDEDim[] called with invalid input {\[Nu]i, \[Nu]j}=",{\[Nu]i,\[Nu]j}];
Print["\[Mu] is reserved for dummy indices and cannot be used as open indices for GCDEDim[]."];
Print["Aborted."];
Abort[];
];
n=dim-2;
If[(!IntegerQ[n])||(n<0),Return[{}]];
coeff=-I (n+1)/(n+2)!;
qSec={Join[{coeff},Subscript[dq,Subscript[\[Mu],#]]&/@Range[1,n]]};
Oper={Join[Subscript[P,Subscript[\[Mu],#]]&/@Range[1,n],{Subscript[F,\[Nu]i,\[Nu]j]}]};
Ord={dim,n,2};
mypoly={{qSec,Oper,Ord}};
mypoly=SimplifyPoly[mypoly];
Return[mypoly];
];


(* ::Subsubsection::Closed:: *)
(*\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) and \!\(\*SubsuperscriptBox[\(P\), \(\[Mu]\), \(CDE\)]\)*)


(* ::Input::Initialization:: *)
Clear[XCDEDim];
Clear[\[CapitalDelta]XStrDimPar];
Clear[\[CapitalDelta]XStrnX];
Clear[\[CapitalDelta]CDEDimGen];
Clear[Load\[CapitalDelta]CDEPolyCache];
Clear[\[CapitalDelta]CDEDim];
Clear[PCDEDim];


(* ::Input::Initialization:: *)
(* Generate the poly X^CDE=(Subscript[q, Subscript[\[Nu], 1]]Subsuperscript[G, Subscript[\[Nu], 1]Subscript[\[Nu], 2], CDE]+\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubscriptBox[\(q\), 
SubscriptBox[\(\[Nu]\), \(1\)]]\))Subscript[dq, Subscript[\[Nu], 2]]-\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(3\)]\), \(CDE\)]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(2\)]]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(3\)]]\ at\ a\ given\ operator\ dimension\) *)
XCDEDim[dim_]:=Module[{polyT1,polyT2,polyT3,polyArray,mypoly},
If[(!IntegerQ[dim])||(dim<2),Return[{}]];
(* the firt two terms (Subscript[q, Subscript[\[Nu], 1]]Subsuperscript[G, Subscript[\[Nu], 1]Subscript[\[Nu], 2], CDE]+\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubscriptBox[\(q\), 
SubscriptBox[\(\[Nu]\), \(1\)]]\))Subscript[dq, Subscript[\[Nu], 2]] *)
polyT1={{{{Subscript[q, Subscript[\[Nu], 1]]}},{},{0,0,1}}};
polyT2=GCDEDim[{Subscript[\[Nu], 1],Subscript[\[Nu], 2]},dim];
polyT3={{{{Subscript[dq, Subscript[\[Nu], 2]]}},{},{0,0,1}}};
mypoly=SumPolys[{MultiplyPolys[{polyT1,polyT2,polyT3}],MultiplyPolys[{polyT2,polyT1,polyT3}]}];
mypoly=ContractPolyIndices[mypoly,{\[Nu]}];
mypoly=SimplifyPoly[mypoly];
(* the last term -\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(3\)]\), \(CDE\)]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(2\)]]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(3\)]]\) *)
polyArray=MultiplyPolys[{GCDEDim[{Subscript[\[Nu], 1],Subscript[\[Nu], 2]},#],GCDEDim[{Subscript[\[Nu], 1],Subscript[\[Nu], 3]},dim-#]}]&/@Range[2,dim-2];
polyT1=SumPolys[polyArray];
polyT2={{{{-1,Subscript[dq, Subscript[\[Nu], 2]],Subscript[dq, Subscript[\[Nu], 3]]}},{},{0,0,2}}};
polyT3=MultiplyPolys[{polyT1,polyT2}];
polyT3=ContractPolyIndices[polyT3,{\[Nu]}];
(* sum the above terms *)
mypoly=SumPolys[{mypoly,polyT3}];
Return[mypoly];
];

(* Compute the poly Subscript[\[CapitalDelta], i]Subscript[X\[CapitalDelta], i]Subscript[X\[CapitalDelta], i]...Subscript[X\[CapitalDelta], i] for a given dimpar of X *)
\[CapitalDelta]XStrDimPar[imass_,dimpar_]:=Module[{polyDelta,polyArray,mypoly},
polyDelta={{{{Subscript[\[CapitalDelta], imass]}},{},{0,0,0}}};
polyArray=MultiplyPolys[{polyDelta,XCDEDim[#]}]&/@dimpar;
mypoly=MultiplyPolys[Join[polyArray,{polyDelta}]];
Return[mypoly];
];

(* Compute the poly Subscript[\[CapitalDelta], i]Subscript[X\[CapitalDelta], i]Subscript[X\[CapitalDelta], i]...Subscript[X\[CapitalDelta], i] with nX of X at a given operator dimension *)
\[CapitalDelta]XStrnX[imass_,nX_,dim_]:=Module[{mydimparlist,polyArray,mypoly},
If[(!IntegerQ[dim])||(dim<2nX),Return[{}]];
mydimparlist=Flatten[Permutations/@IntegerPartitions[dim-nX,{nX}],1]+1;
polyArray=\[CapitalDelta]XStrDimPar[imass,#]&/@mydimparlist;
mypoly=SumPolys[polyArray];
Return[mypoly];
];

(* Generate the poly Subsuperscript[\[CapitalDelta], i, CDE]=Subscript[\[CapitalDelta], i]+Subscript[\[CapitalDelta], i]X^CDESubscript[\[CapitalDelta], i]+Subscript[\[CapitalDelta], i]X^CDESubscript[\[CapitalDelta], i]X^CDESubscript[\[CapitalDelta], i]+... at a given operator dimension *)
\[CapitalDelta]CDEDimGen[imass_,dim_]:=Module[{polyArray,mypoly},
If[(!IntegerQ[dim])||(dim<0),Return[{}]];
polyArray=\[CapitalDelta]XStrnX[imass,#,dim]&/@Range[0,Floor[dim/2]];
mypoly=SumPolys[polyArray];
Return[mypoly];
];

(* Load the quantity \[CapitalDelta]CDEPolyCache that stores the pre-evaluated \[CapitalDelta]CDE polys *)
Load\[CapitalDelta]CDEPolyCache[]:=Module[{},
\[CapitalDelta]CDEPolyCache=\[CapitalDelta]CDEDimGen[1,#]&/@Range[0,10];
Return[];
];

(* Get the poly Subsuperscript[\[CapitalDelta], i, CDE] at a given operator dimension *)
\[CapitalDelta]CDEDim[imass_,dim_]:=Module[{},
If[(!IntegerQ[dim])||(dim<0),Return[{}]];
If[(!ValueQ[\[CapitalDelta]CDEPolyCache])||(dim>10),Return[\[CapitalDelta]CDEDimGen[imass,dim]]];
Return[\[CapitalDelta]CDEPolyCache[[dim+1]]/.{Subscript[\[CapitalDelta], 1]->Subscript[\[CapitalDelta], imass]}];
];

(* Generate the poly Subsuperscript[P, Subscript[\[Nu], i], CDE]=-Subscript[q, Subscript[\[Nu], i]]+\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(i\)]
\*SubscriptBox[\(\[Nu]\), \(0\)]\), \(CDE\)]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(0\)]]\ at\ a\ given\ operator\ dimension\) *)
PCDEDim[\[Nu]i_,dim_]:=Module[{polyT1,polyT2,mypoly},
(* Abort if \[Nu]i is Subscript[\[Mu], __] *)
If[MatchQ[\[Nu]i,Subscript[\[Mu], _]],
Print["PCDEDim[] called with invalid input \[Nu]i=",\[Nu]i];
Print["\[Mu] is reserved for dummy indices and cannot be used as open indices for PCDEDim[]."];
Print["Aborted."];
Abort[];
];
If[dim==0,Return[{{{{-1,Subscript[q, \[Nu]i]}},{},{0,0,1}}}]];
If[dim<2,Return[{}]];
polyT1=GCDEDim[{\[Nu]i,Subscript[\[Nu], 0]},dim];
polyT2={{{{Subscript[dq, Subscript[\[Nu], 0]]}},{},{0,0,1}}};
mypoly=MultiplyPolys[{polyT1,polyT2}];
mypoly=ContractPolyIndices[mypoly,{\[Nu]}];
Return[mypoly];
];


(* ::Subsection:: *)
(*Supertrace Manipulations*)


(* ::Text:: *)
(*Descriptions*)


(* ::Input::Initialization:: *)
(*
\!\(\(STrEAM\ evaluates\ functional\ supertraces\ of\ the\ form\[IndentingNewLine]\ \  - iSTr[f]\)
\*SubscriptBox[\(|\), \(hard\)]\);
where f a product sequence of Subscript[P, \[Mu]], Subscript[U, k], Subscript[\[CapitalDelta], i] and Subscript[\[CapitalLambda], i], consisting of an arbitrary number of "propagator blocks"
f=[ ... (\!\(
\*SubsuperscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)], \(CDE\)] ... \)Subsuperscript[P, Subscript[\[Mu], n], CDE])(\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\ or\ 
\*SubsuperscriptBox[\(\[CapitalLambda]\), \(i\), \(CDE\)]\))(\!\(
\*SubsuperscriptBox[\(P\), 
SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)] ... \)Subsuperscript[P, Subscript[\[Nu], m], CDE])Subsuperscript[U, k, CDE] ... ];
where the propagator can be either bosonic Subsuperscript[\[CapitalDelta], i, CDE], or fermionic Subsuperscript[\[CapitalLambda], i, CDE]; the last Subsuperscript[U, k, CDE] factor is allowed to be absent;

Fermionic propagators are addressed by
 Subsuperscript[\[CapitalLambda], i, CDE]=1/(Pslash-Subscript[m, i])=1/(P^2-Subsuperscript[m, i, 2]-\[CapitalSigma])(Subscript[m, i]+Subscript[P, \[Rho]]Subscript[\[Gamma], \[Rho]])=(\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)] + \(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) + \(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) + \)...)(Subscript[m, i]+Subscript[P, \[Rho]]Subscript[\[Gamma], \[Rho]]);
with
\[CapitalSigma]=-(1/2)\[Sigma]^\[Alpha]\[Beta]Subscript[F, \[Alpha]\[Beta]]=-(1/2)\[Sigma]F;
We call the supertrace "bosonic" when it contains no fermionic propagators;

Mandatory input parameters for the main function SuperTrace[];
dim          Desired operator dimension in the result;
flist        Functional operator f to trace over;

Options for the main function SuperTrace[];
Udimlist     default {1,...,1}    Minimum operator dimensions of {Subscript[U, k]};
Heavylist    default    {1}       Heavy mass labels;
SoftOrd      default     0        Additional power(s) of Subscript[m, light]/Subscript[m, heavy];
No\[Gamma]inU       default   False      No Dirac matrices Subscript[\[Gamma], \[Mu]] in {Subscript[U, k]};
display      default   False      Print result;

Alternatively, one can use the function SuperTraceFromExpr, which takes an expression fexpr as input for the functional operator f;

The set of underlying supertrace "parameters" for the functional operator f (only used in private context);
masslabels   List of propagator masses, namely the {Subscript[i, 1],Subscript[i, 2],...} in f;
typelist     List of propagator types +1 for Subscript[\[CapitalDelta], i], -1 or Subscript[\[CapitalLambda], i];
coeff        Coefficient multiplying the supertrace;
Ulist        List of Subscript[U, k] factors, with default value {Subscript[U, 1],Subscript[U, 2],Subscript[U, 3],...};
Plocations   List of locations of Subsuperscript[P, Subscript[\[Nu], i], CDE], with -n(+n) indicating before(after) the nth propagator;
Pindices     List of Lorentz indices Subscript[\[Nu], i] in the open covariant derivatives Subsuperscript[P, Subscript[\[Nu], i], CDE];
Udimlist     List of minimum operator dimensions of {Subscript[U, k]};
*)


(* ::Subsubsection::Closed:: *)
(*Bosonic Supertrace CDE Poly Generation*)


(* ::Input::Initialization:: *)
Clear[STrPrint];
Clear[STrParameters];
Clear[STrBflists];
Clear[STrflistUFrame];
Clear[DimparsBSTrDim];
Clear[BSTrPolyDimPar];
Clear[BSTrPolyGen];


(* ::Input::Initialization:: *)
(* Print the input supertrace *)
STrPrint[flist_]:=Module[{mylist},
mylist=Flatten[Flatten[{ReplaceAll[#,{Times->List,NonCommutativeMultiply->List}]}]&/@flist];
mylist=Join[{Times@@(Select[mylist,NumericQ])},DeleteCases[mylist,_?NumericQ]];
If[mylist[[1]]===1,mylist=mylist[[2;;]]];
If[mylist[[1]]===-1,mylist=ReplacePart[mylist,1->"-"]];
mylist=mylist/.{Subscript[\[CapitalDelta], i_]->If[i==0,1/P^2,1/(P^2-\!\(\*SubsuperscriptBox[\(m\), \(i\), \(2\)]\))],Subscript[\[CapitalLambda], j_]->If[j==0,"\!\(\*FractionBox[\(1\), \(\(Pslash\)\(\\\ \)\)]\)",1/(Pslash - Subscript[m, j])]};
mylist=Join[{"-iSTr["},mylist,{"]\!\(\*SubscriptBox[\(|\), \(hard\)]\)"}];
Return[Row[mylist]];
];

(* Get the set of underlying supertrace "parameters" for flist *)
STrParameters[flist_,Udimlist_]:=Module[{myflist,masslabels,mytypelist,my\[CapitalDelta]split,mycoeff,Ucoefflist,Uoperlist,myUlist,myUdimlist,myP\[CapitalDelta]PUlist,myP\[CapitalDelta]PUsplit,myPlocations,myPindices,myParameters},
(* canonicalize flist into myflist *)
myflist=Join@@(Flatten[{ReplaceAll[#,{Times->List,NonCommutativeMultiply->List}]}]&/@flist);
If[!NumericQ[myflist[[1]]],myflist=Insert[myflist,1,1]];
(* masslabels and propagator types *)
masslabels=Cases[myflist,Subscript[\[CapitalDelta], i_]|Subscript[\[CapitalLambda], i_]->i];
mytypelist=Cases[myflist,Subscript[\[CapitalDelta], __]|Subscript[\[CapitalLambda], __]]/.{Subscript[\[CapitalDelta], __]->1,Subscript[\[CapitalLambda], __]->-1};
If[masslabels==={},
Print["No propagators detected in the input flist."];
Print["Aborted."];
Abort[];
];
(* coeff, Ulist, and Udimlist *)
If[SequenceCount[DeleteCases[myflist,_?NumericQ|Subscript[m, __]|Subscript[\[Eta], __]|Subscript[\[Gamma], __]|Subscript[P, __]]/.{Subscript[\[CapitalDelta], __]|Subscript[\[CapitalLambda], __]->\[CapitalDelta]},{\[CapitalDelta],\[CapitalDelta]}]>0,
Print["Missing U factor between \[CapitalDelta]|\[CapitalLambda] in the input flist."];
Print["Aborted."];
Abort[];
];
my\[CapitalDelta]split=Split[myflist,!MatchQ[#2,Subscript[\[CapitalDelta], __]|Subscript[\[CapitalLambda], __]]&];
mycoeff=Times@@DeleteCases[my\[CapitalDelta]split[[1]],Subscript[P, __]];
my\[CapitalDelta]split=my\[CapitalDelta]split[[2;;]];
Ucoefflist=(Times@@Cases[#,_?NumericQ|Subscript[m, __]|Subscript[\[Eta], __]])&/@my\[CapitalDelta]split;
Uoperlist=DeleteCases[#,_?NumericQ|Subscript[m, __]|Subscript[\[Eta], __]|Subscript[\[CapitalDelta], __]|Subscript[\[CapitalLambda], __]|Subscript[P, __]]&/@my\[CapitalDelta]split;
Uoperlist=If[Length[#]>1,#/.List->NonCommutativeMultiply,#/.List->Times]&/@Uoperlist;
myUlist=MapThread[#1 #2&,{Ucoefflist,Uoperlist}];
If[(Length[Udimlist]!=0)&&(Length[Udimlist]!=Length[myUlist]),
Print["Mismatch between the length of U and Udim: Ulist=",myUlist,", Udimlist=",Udimlist];
Print["Aborted."];
Abort[];
];
If[Udimlist==={},myUdimlist=1&/@myUlist,myUdimlist=Udimlist];
If[Last[myUlist]===1,myUdimlist[[-1]]=0];
(* Plocations and Pindices *)
myP\[CapitalDelta]PUlist=DeleteCases[myflist,_?NumericQ|Subscript[m, __]|Subscript[\[Eta], __]|Subscript[\[Gamma], __]]/.{Subscript[P, __]->P,Subscript[\[CapitalDelta], __]|Subscript[\[CapitalLambda], __]->\[CapitalDelta]};
myP\[CapitalDelta]PUsplit=Split[myP\[CapitalDelta]PUlist,(MatchQ[#1,\[CapitalDelta]|P]||!MatchQ[#2,\[CapitalDelta]|P])&];
myP\[CapitalDelta]PUsplit=MapThread[(Cases[#1,P|\[CapitalDelta]]/.{P->0,\[CapitalDelta]->#2})&,{myP\[CapitalDelta]PUsplit,Range[Length[myP\[CapitalDelta]PUsplit]]}];
myPlocations=Join@@(DeleteCases[Accumulate[#]-Reverse[Accumulate[Reverse[#]]],0]&/@myP\[CapitalDelta]PUsplit);
myPindices=Cases[myflist,Subscript[P, \[Nu]_]->\[Nu]];
(* put all the inputs together *)
myParameters={masslabels,mytypelist,mycoeff,myUlist,myPlocations,myPindices,myUdimlist};
Return[myParameters];
];

(* Get the set of bosonic flists from a given flist *)
STrBflists[flist_,n\[CapitalSigma]cap_]:=Module[{myParameters,bflistTuples,\[Rho]shiftArray,bflistArray},
bflistTuples=Tuples[(If[MatchQ[#,Subscript[\[CapitalLambda], __]],#,{{#}}]&/@flist)/.{Subscript[\[CapitalLambda], i_]:>Flatten/@Tuples[{NestList[Join[#,{-(1/2),\[Sigma]F,Subscript[\[CapitalDelta], i]}]&,{Subscript[\[CapitalDelta], i]},n\[CapitalSigma]cap],
DeleteCases[{{Subscript[m, i],1},{Subscript[P, Subscript[\[Rho], 0]],1,Subscript[\[Gamma], Subscript[\[Rho], 0]]}},_?(MemberQ[#,Subscript[m, 0]]&)]}]}];
\[Rho]shiftArray=Join[{0},Accumulate[(Count[#,Subscript[\[Rho], 0],All]&/@#)[[;;-2]]]/2]&/@bflistTuples;
bflistArray=Flatten/@MapThread[MapThread[#1/.{Subscript[\[Rho], 0]->Subscript[\[Rho], #2+1]}&,{#1,#2}]&,{bflistTuples,\[Rho]shiftArray}];
bflistArray=Select[bflistArray,(Count[#,\[Sigma]F]<=n\[CapitalSigma]cap)&];
Return[bflistArray];
];

(* Obtain the UFrame of flist *)
STrflistUFrame[masslabels_,typelist_,coeff_,Plocations_,Pindices_]:=Module[{myUlist,\[CapitalDelta]lsit,\[CapitalDelta]Ulist,poslist,Porders,myflist},
myUlist=Subscript[U, #]&/@Range[Length[masslabels]];
\[CapitalDelta]lsit=MapThread[If[#2>0,Subscript[\[CapitalDelta],#1],Subscript[\[CapitalLambda],#1]]&,{masslabels,typelist}];
\[CapitalDelta]Ulist=Riffle[\[CapitalDelta]lsit,myUlist];
poslist={If[#>0,2#,-2#-1]}&/@Plocations;
myflist=Insert[\[CapitalDelta]Ulist,P,poslist];
Porders=Accumulate[If[#===P,1,0]&/@myflist];
myflist=MapThread[If[#1===P,Subscript[P,Pindices[[#2]]],#1]&,{myflist,Porders}];
myflist=Join[{coeff},myflist];
Return[myflist];
];

(* Get the list of dimension partitions of a given dim for a bosonic supertrace *)
DimparsBSTrDim[dim_,masslabels_,Plocations_,Udimlist_]:=Module[{\[CapitalDelta]mindim,Umindim,mindimlist,poslist,ULastdim,dimparshift,dimeff,mydimparlist},
\[CapitalDelta]mindim=0&/@masslabels;
Umindim=Udimlist;
mindimlist=Riffle[\[CapitalDelta]mindim,Umindim];
poslist={If[#>0,2#,-2#-1]}&/@Plocations;
mindimlist=Insert[mindimlist,0,poslist];
ULastdim=Last[Udimlist];
mindimlist=mindimlist[[;;-2]];
dimparshift=mindimlist-1;
dimeff=dim-ULastdim-(Plus@@dimparshift);
mydimparlist=Flatten[Permutations/@IntegerPartitions[dimeff,{Length[mindimlist]}],1];
mydimparlist=Join[#+dimparshift,{ULastdim}]&/@mydimparlist;
(* trimings *)
If[!MemberQ[Plocations,-1],mydimparlist=Select[mydimparlist,#[[1]]!=2&]];
If[!MemberQ[Plocations,Length[masslabels]],mydimparlist=Select[mydimparlist,#[[-2]]!=2&]];
Return[mydimparlist];
];

(* Generate the poly of a bosonic supertrace for a given dimpar *)
BSTrPolyDimPar[dimpar_,masslabels_,coeff_,Ulist_,Plocations_,Pindices_,Udimlist_]:=Module[{mytypelist,mylist,myexpr,polyArray,mypoly},
mytypelist=1&/@masslabels;
mylist=STrflistUFrame[masslabels,mytypelist,1,Plocations,Pindices];
mylist=mylist[[2;;]];
polyArray=MapThread[(#1/.{Subscript[\[CapitalDelta], imass_]:>\[CapitalDelta]CDEDim[imass,#2],Subscript[U, i_]:> UCDEDim[#2,Udim->Udimlist[[i]],Uoper->Ulist[[i]]],Subscript[P, \[Nu]_]:>PCDEDim[\[Nu],#2]})&,{mylist,dimpar}];
mypoly=MultiplyPolys[polyArray];
mypoly=ContractPolyIndices[mypoly,{\[Nu],\[Rho]}];
mypoly=FTrimPoly[mypoly];
mypoly=ScalePoly[mypoly,coeff];
Return[mypoly];
];

(* Generate the poly of a bosonic supertrace up to a given operator dimension *)
BSTrPolyGen[dim_,masslabels_,coeff_,Ulist_,Plocations_,Pindices_,Udimlist_]:=Module[{mydimparlist,polyArray,myexpr,mypoly},
mydimparlist=Flatten[DimparsBSTrDim[#,masslabels,Plocations,Udimlist]&/@Range[Length[masslabels],dim],1];
polyArray=BSTrPolyDimPar[#,masslabels,coeff,Ulist,Plocations,Pindices,Udimlist]&/@mydimparlist;
mypoly=SumPolys[polyArray];
Return[mypoly];
];


(* ::Subsubsection::Closed:: *)
(*General Supertrace (Main Functions)*)


(* ::Input::Initialization:: *)
Clear[SuperTrace]; 
Clear[SuperTraceFromExpr];


(* ::Input::Initialization:: *)
(* \!\(\(Compute\ a\ functional\ supertrace\  - iSTr[f]\)
\*SubscriptBox[\(|\), \(hard\)]\ \(up\ to\ a\ given\ operator\ dimension\ dim\)\) *)
SuperTrace[dim_,flist_,OptionsPattern[{Udimlist->{},Heavylist->{1},SoftOrd->0,No\[Gamma]inU->False,display->False}]]:=Module[{myflist,myParameters,masslabels,typelist,coeff,Ulist,Plocations,Pindices,myUdimlist,myHeavylist,mySoftOrd,n\[Nu],\[Mu]start,\[Rho]start,supersign,flistU,n\[CapitalSigma]cap,bflistArray,UdimlistArray,BSTrInputArray,polyArray,mypoly,myInput,myPrint,mystr},
(**)
(*************************************************************************************)
(********************************** Interpret Inputs ***********************************)
(*************************************************************************************)
(**)
myflist=flist;
myParameters=STrParameters[myflist,OptionValue[Udimlist]];
masslabels=myParameters[[1]];
typelist=myParameters[[2]];
coeff=myParameters[[3]];
Ulist=myParameters[[4]];
Plocations=myParameters[[5]];
Pindices=myParameters[[6]];
myUdimlist=myParameters[[7]];
(**)
(*************************************************************************************)
(******************************* Check Validity of Inputs *******************************)
(*************************************************************************************)
(**)
(* masslabels *)
If[(!AllTrue[masslabels,IntegerQ])||(Min[masslabels]<0),
Print["SuperTrace[] called with invalid mass labels:",masslabels];
Print["mass labels must be non-negative integers."];
Print["Aborted."];
Abort[];
];
(* Ulist *)
If[Length[Ulist]!=Length[masslabels],
Print["SuperTrace[] called with different numbers of \[CapitalDelta]|\[CapitalLambda] and U: propagators=",Cases[flist,Subscript[\[CapitalDelta], i_]|Subscript[\[CapitalLambda], i_]],", Ulist=",Ulist];
Print["Aborted."];
Abort[];
];
(* Plocations *)
If[(Max[Plocations]>Length[masslabels])||(Min[Plocations]<-Length[masslabels])||MemberQ[Plocations,0],
Print["SuperTrace[] called with invalid Plocations=",Plocations];
Print["Aborted."];
Abort[];
];
(* Pindices *)
If[Select[Tally[Pindices],#[[2]]>2&]=!={},
Print["SuperTrace[] called with invalid P Lorentz indies:",Pindices];
Print["The same Lorentz index should not appear more than twice."];
Print["Aborted."];
Abort[];
];
(* Pindices: replace \[Mu] indices in the input with \[Nu] indices *)
If[MemberQ[Pindices,Subscript[\[Mu], _]],
n\[Nu]=Max[Join[{0},Cases[Pindices,Subscript[\[Nu], i_]->i]]];
\[Mu]start=Min[Cases[Pindices,Subscript[\[Mu], i_]->i]];
Print["\[Mu] indices are reserved by the code. Proceeding with the following indices replacements:"];
Print[Subscript[\[Mu], #]->Subscript[\[Nu], n\[Nu]+#-\[Mu]start+1]]&/@Sort[DeleteDuplicates[Cases[Pindices,Subscript[\[Mu], i_]->i]]];
Pindices=Pindices/.{Subscript[\[Mu], i_]->Subscript[\[Nu], n\[Nu]+i-\[Mu]start+1]};
myflist=myflist/.{Subscript[\[Mu], i_]->Subscript[\[Nu], n\[Nu]+i-\[Mu]start+1]};
];
(* Pindices: replace \[Rho] indices in the input with \[Nu] indices *)
If[MemberQ[Pindices,Subscript[\[Rho], _]],
n\[Nu]=Max[Join[{0},Cases[Pindices,Subscript[\[Nu], i_]->i]]];
\[Rho]start=Min[Cases[Pindices,Subscript[\[Rho], i_]->i]];
Print["\[Rho] indices are reserved by the code. Proceeding with the following indices replacements:"];
Print[Subscript[\[Rho], #]->Subscript[\[Nu], n\[Nu]+#-\[Rho]start+1]]&/@Sort[DeleteDuplicates[Cases[Pindices,Subscript[\[Rho], i_]->i]]];
Pindices=Pindices/.{Subscript[\[Rho], i_]->Subscript[\[Nu], n\[Nu]+i-\[Rho]start+1]};
myflist=myflist/.{Subscript[\[Rho], i_]->Subscript[\[Nu], n\[Nu]+i-\[Rho]start+1]};
];
(* Heavylist *)
myHeavylist=OptionValue[Heavylist];
If[Intersection[masslabels,myHeavylist]==={},
Print["flist contains no heavy mass: Heavylist=",myHeavylist,", while masslabels=",masslabels];
Print["Supertrace vanishes."];
Return[{}];
];
(* SoftOrd *)
mySoftOrd=OptionValue[SoftOrd];
If[(!IntegerQ[mySoftOrd])||(mySoftOrd<0),
Print["SuperTrace[] called with invalid SoftOrd=",mySoftOrd];
Print["Aborted."];
Abort[];
];
(**)
(*************************************************************************************)
(******************************* Evaluate the SuperTrace ********************************)
(*************************************************************************************)
(**)
(* Address the "super" in STr *)
supersign=typelist[[1]];
coeff=supersign*coeff;
(**)
(* Address fermionic propagators *)
flistU=STrflistUFrame[masslabels,typelist,coeff,Plocations,Pindices];
n\[CapitalSigma]cap=Floor[(dim-(Plus@@myUdimlist))/2];If[n\[CapitalSigma]cap<0,n\[CapitalSigma]cap=0];
bflistArray=STrBflists[flistU,n\[CapitalSigma]cap];
UdimlistArray=(Cases[#,\[Sigma]F|Subscript[U, __]]/.{\[Sigma]F->2,Subscript[U, i_]:>myUdimlist[[i]]})&/@bflistArray;
bflistArray=(#/.{Subscript[U, i_]:>Ulist[[i]]})&/@bflistArray;
BSTrInputArray=MapThread[STrParameters[#1,#2]&,{bflistArray,UdimlistArray}];
BSTrInputArray=Join[{dim},Delete[#,2]]&/@BSTrInputArray;
(**)
(* Perform original CDE *)
mypoly=SumPolys[(BSTrPolyGen@@#)&/@BSTrInputArray];
(**)
(* Perform loop integrals *)
mypoly=qEvenTrimPoly[mypoly];
mypoly=dqAllPoly[mypoly];
mypoly=SimplifyPoly[mypoly];
mypoly=FTrimPoly[mypoly];
mypoly=SymHardPoly[mypoly,dim,myHeavylist,mySoftOrd,OptionValue[No\[Gamma]inU]];
mypoly=IntegratePoly[mypoly];
mystr=ReplacePart[#,3->#[[3]][[1]]]&/@mypoly;
mystr=mystr/.{Log[\!\(\*SubsuperscriptBox[\(m\), \(i_\), \(2\)]\)]->Log[\!\(\*SubsuperscriptBox[\(m\), \(i\), \(2\)]\)/\[Mu]^2]};
(**)
(* Print results *)
If[OptionValue[display],
myInput=STrPrint[myflist];
myPrint=ReplacePart[#,2->{{Row[Row[Join[{"("},{Row[#]},{")"}]]&/@(#[[2]])]}}]&/@mystr;
myPrint=ReplacePart[#,3->{{Row[{"(dim-",#[[3]],")"}]}}]&/@myPrint;
Print[myInput," = \[Integral]\!\(\*SuperscriptBox[\(d\), \(4\)]\)x \!\(\*FractionBox[\(1\), \(16 \*SuperscriptBox[\(\[Pi]\), \(2\)]\)]\) tr{\n",TableForm[myPrint,TableSpacing->{5,5,2}]];
Print["}"];
];
Return[mystr];
];

(* \!\(\(Compute\ a\ functional\ supertrace\  - iSTr[f]\)
\*SubscriptBox[\(|\), \(hard\)]\ \(up\ to\ a\ given\ operator\ dimension\ dim\)\) *)
SuperTraceFromExpr[dim_,fexpr_,OptionsPattern[{Udimlist->{},Heavylist->{1},SoftOrd->0,No\[Gamma]inU->False,display->False}]]:=Module[{myflist,mystr},
myflist=Flatten[{fexpr/.{Times->List,NonCommutativeMultiply->List}}];
mystr=SuperTrace[dim,myflist,Udimlist->OptionValue[Udimlist],Heavylist->OptionValue[Heavylist],SoftOrd->OptionValue[SoftOrd],No\[Gamma]inU->OptionValue[No\[Gamma]inU],display->OptionValue[display]];
Return[mystr];
];


(* ::Section:: *)
(*End the `Private context*)


(* ::Input::Initialization:: *)
End[]


(* ::Section:: *)
(*End the package context*)


(* ::Input::Initialization:: *)
EndPackage[]
