(* ::Package:: *)

(* ::Title:: *)
(*STrEAM.m Package*)


(* ::Text:: *)
(*SuperTrace Evaluation Automated for Matching*)
(*by Timothy Cohen, Xiaochuan Lu, and Zhengkang Zhang*)
(*Last edited on December 11, 2020.*)


(* ::Section:: *)
(*Begin the package*)


(* ::Input::Initialization:: *)
BeginPackage["STrEAM`"]


(* ::Subsection:: *)
(*Usage messages for the public functions*)


(* ::Input::Initialization:: *)
(* Reserved for input recognition *)
P::usage="\!\(\*SubscriptBox[\(P\), \(\[Mu]\)]\)=\!\(\*SubscriptBox[\(iD\), \(\[Mu]\)]\) denote the Hermitian covariant derivatives in input and output.";
\[CapitalDelta]::usage="\!\(\*SubscriptBox[\(\[CapitalDelta]\), \(i\)]\)=\!\(\*FractionBox[\(1\), \(\*SuperscriptBox[\(P\), \(2\)] - \*SubsuperscriptBox[\(m\), \(i\), \(2\)]\)]\) denotes bosonic covariant propagators in input and its print.";
\[CapitalLambda]::usage="\!\(\*SubscriptBox[\(\[CapitalLambda]\), \(i\)]\)=\!\(\*FractionBox[\(1\), \(Pslash - \*SubscriptBox[\(m\), \(i\)]\)]\) denotes fermionic covariant propagators in input and its print.";

(* Reserved as dummy indices *)
\[Mu]::usage="\!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\) denote dummy indices in output.";

(* Reserved for output *)
m::usage="\!\(\*SubscriptBox[\(m\), \(i\)]\) with i non-negative integers denote particle masses.";
d::usage="d denotes the spacetime dimension in dimensional regularization.";
\[Eta]::usage="\!\(\*SubscriptBox[\(\[Eta]\), \(\[Mu], \[Nu]\)]\)=diag(1,-1,-1,-1) denotes the spacetime metric.";
\[CurlyEpsilon]::usage="\!\(\*SubscriptBox[\(\[CurlyEpsilon]\), \(\[Mu], \[Nu], \[Rho], \[Sigma]\)]\) denote the Levi-Civita symbol, with \!\(\*SubscriptBox[\(\[CurlyEpsilon]\), \(0123\)]\)=-1.";
F::usage="\!\(\*SubscriptBox[\(F\), \(\[Mu], \[Nu]\)]\)=-i[\!\(\*SubscriptBox[\(P\), \(\[Mu]\)]\),\!\(\*SubscriptBox[\(P\), \(\[Nu]\)]\)]=\!\(\*SubscriptBox[\(g\), \(a\)]\)\!\(\*SubsuperscriptBox[\(G\), \(\[Mu]\[Nu]\), \(a\)]\)\!\(\*SuperscriptBox[\(T\), \(a\)]\) denotes the sum of field strengths.";
\[Gamma]::usage="\!\(\*SubscriptBox[\(\[Gamma]\), \(\[Mu]\)]\) denote Dirac matrices.";
\[Sigma]F::usage="\[Sigma]F denotes \!\(\*SuperscriptBox[\(\[Sigma]\), \(\[Mu]\[Nu]\)]\)\!\(\*SubscriptBox[\(F\), \(\[Mu]\[Nu]\)]\)=\!\(\*FractionBox[\(i\), \(2\)]\)[\!\(\*SuperscriptBox[\(\[Gamma]\), \(\[Mu]\)]\),\!\(\*SuperscriptBox[\(\[Gamma]\), \(\[Nu]\)]\)]\!\(\*SubscriptBox[\(F\), \(\[Mu]\[Nu]\)]\) in the dipole factor \[CapitalSigma]=-\!\(\*FractionBox[\(1\), \(2\)]\)\!\(\*SuperscriptBox[\(\[Sigma]\), \(\[Mu]\[Nu]\)]\)\!\(\*SubscriptBox[\(F\), \(\[Mu]\[Nu]\)]\).";
Pslash::usage="Pslash=\!\(\*SubscriptBox[\(P\), \(\[Mu]\)]\)\!\(\*SuperscriptBox[\(\[Gamma]\), \(\[Mu]\)]\)";
LoopI::usage="\!\(\*FractionBox[\(1\), \(16 \*SuperscriptBox[\(\[Pi]\), \(2\)]\)]\)\!\(\*SubsuperscriptBox[\(LoopI\), \((\*SubscriptBox[\(n\), \(1\)],  ... , \*SubscriptBox[\(n\), \(k\)])\), \((r)\)]\)(\!\(\*SubsuperscriptBox[\(m\), \(1\), \(2\)]\),...,\!\(\*SubsuperscriptBox[\(m\), \(k\), \(2\)]\))=-i\[Integral]\!\(\*FractionBox[\(\*SuperscriptBox[\(d\), \(d\)] q\), SuperscriptBox[\((2  \[Pi])\), \(d\)]]\)\!\(\*FractionBox[SuperscriptBox[\((\*SuperscriptBox[\(q\), \(2\)])\), \(r\)], \(\(\*SuperscriptBox[\((\*SuperscriptBox[\(q\), \(2\)] - \*SubsuperscriptBox[\(m\), \(1\), \(2\)])\), SubscriptBox[\(n\), \(1\)]] ... \) \*SuperscriptBox[\((\*SuperscriptBox[\(q\), \(2\)] - \*SubsuperscriptBox[\(m\), \(k\), \(2\)])\), SubscriptBox[\(n\), \(k\)]]\)]\)";

(* Main Functions *)
SuperTrace::usage="SuperTrace[dim,flist] evaluates -iSTr[f]\!\(\*SubscriptBox[\(|\), \(hard\)]\) up to operator dimension dim.";
SuperTraceFromExpr::usage="SuperTraceFromExpr[dim,fexpr] evaluates -iSTr[f]\!\(\*SubscriptBox[\(|\), \(hard\)]\) up to operator dimension dim.";


(* ::Section:: *)
(*Begin the `Private context*)


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Subsection::Closed:: *)
(*qSection Manipulations*)


(* ::Text::Closed:: *)
(*Descriptions*)


(* ::Input::Initialization:: *)
(*
"qSec" stores the q-sections (loop momentum dependence) of terms in intermediate steps in the CDE procedure;
They are essentially just functions in the loop momentum Subscript[q, \[Mu]];
When generated by CDE, they are polynomials of Subscript[q, \[Mu]], Subscript[dq, \[Mu]](derivatives on Subscript[q, \[Mu]]), and Subscript[\[CapitalDelta], i]=1/(q^2-Subsuperscript[m, i, 2]);
Note that in the context of "qSec", Subscript[\[CapitalDelta], i] is understood as an ordinary loop propagator, different from an input "Subscript[\[CapitalDelta], i]", where it is interpreted as Subsuperscript[\[CapitalDelta], i, CDE] (see later sections);

Concretely, a "qSec" is a list of "qPart", while a "qPart" is simply a list of factors, such as
qPart={1/30,Subscript[\[CapitalDelta], 1],Subscript[q, Subscript[\[Mu], 4]],Subscript[dq, Subscript[\[Mu], 1]],Subscript[dq, Subscript[\[Mu], 2]],Subscript[dq, Subscript[\[Mu], 3]],Subscript[dq, Subscript[\[Mu], 5]],Subscript[\[CapitalDelta], 1]};

In the end, the derivatives Subscript[dq, \[Mu]] in qSec will be carried out and the loop integral
-i\[Integral](d^dq)/(2\[Pi])^d will be performed on qSec;
The function LoopInt is parameterized as
1/(16\[Pi]^2)Subsuperscript[LoopI, (Subscript[n, 1],...,Subscript[n, k]), (r)](\!\(
\*SubsuperscriptBox[\(m\), \(1\), \(2\)],  ... , 
\*SubsuperscriptBox[\(m\), \(k\), \(2\)]\))=-i\[Integral](d^dq)/(2\[Pi])^d(q^2)^r/((q^2-Subsuperscript[m, 1, 2])^Subscript[n, 1]...(q^2-Subsuperscript[m, k, 2])^Subscript[n, k]);
which is evaluated using dim reg (d=4-2\[Epsilon]) under the MSbar scheme;
When there are less than three distinct masses, LoopInt returns the explicit value;
When there are three or more non-degenerate masses, LoopInt leaves the result abstract as the LHS above.
*)


(* ::Subsubsection::Closed:: *)
(*qPart and qSec Arithmetic*)


(* ::Input::Initialization:: *)
Clear[qPartCommuting];
Clear[q2dq2\[Eta]2Rules]; 
Clear[SplitqPart];
Clear[ExprqPart];
Clear[qPartFromExpr];
Clear[SimplifyqPart];
Clear[SimplifyqSec]; 
Clear[ScaleqSec];
Clear[MultiplyqSecs];


(* ::Input::Initialization:: *)
(* Commuting condition for two adjacent elements in qPart *)
qPartCommuting=(MatchQ[#1,Subscript[dq, __]]&&MatchQ[#2,Subscript[dq, __]])||(!MatchQ[#1,Subscript[dq, __]]&&!MatchQ[#2,Subscript[dq, __]])&;

(* Rules for writing Subsuperscript[q, \[Nu], 2], Subsuperscript[dq, \[Nu], 2], and Subsuperscript[\[Eta], a_, 2] *)
q2dq2\[Eta]2Rules={\!\(
\*SubsuperscriptBox[\(q\), \(\[Nu]_\), \(2\)] -> \({
\*SubscriptBox[\(q\), \(\[Nu]\)], 
\*SubscriptBox[\(q\), \(\[Nu]\)]}\)\),\!\(
\*SubsuperscriptBox[\(dq\), \(\[Nu]_\), \(2\)] -> \({
\*SubscriptBox[\(dq\), \(\[Nu]\)], 
\*SubscriptBox[\(dq\), \(\[Nu]\)]}\)\),\!\(
\*SubsuperscriptBox[\(\[Eta]\), \(a__\), \(2\)] -> \({
\*SubscriptBox[\(\[Eta]\), \(a\)], 
\*SubscriptBox[\(\[Eta]\), \(a\)]}\)\),\!\(
\*SubsuperscriptBox[\(\[CurlyEpsilon]\), \(a__\), \(2\)] -> \({
\*SubscriptBox[\(\[CurlyEpsilon]\), \(a\)], 
\*SubscriptBox[\(\[CurlyEpsilon]\), \(a\)]}\)\)};

(* Split a qPart into commuting segments, with the first one reserved for coefficient *)
SplitqPart[qPart_]:=Module[{coeff,myqPart,myqPartSplit},
coeff=Times@@(Cases[qPart,_?NumericQ]);
myqPart=Join[Cases[qPart,Subscript[m, _]],Cases[qPart,Subscript[\[Eta], __]],Cases[qPart,Subscript[\[CurlyEpsilon], __]],DeleteCases[qPart,_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[CurlyEpsilon], __]]];
myqPartSplit=Join[{{coeff}},Split[myqPart,qPartCommuting]];
Return[myqPartSplit];
];

(* Get the "qPart expression" from a qPart list *)
ExprqPart[qPart_]:=Module[{qPartGrouped,myqPartSplit,myexpr},
myqPartSplit=SplitqPart[qPart];
qPartGrouped=(Times@@#)&/@myqPartSplit;
myexpr=If[Length[qPartGrouped]>2,qPartGrouped[[1]] NonCommutativeMultiply@@qPartGrouped[[2;;]],Times@@qPartGrouped];
Return[myexpr];
];

(* Convert a "qPart expression" back to the qPart list *)
qPartFromExpr[expr_]:=Module[{myqPart},
myqPart=Flatten[{expr/.{Times->List,NonCommutativeMultiply->List}/.q2dq2\[Eta]2Rules}];
If[!NumericQ[myqPart[[1]]],myqPart=Insert[myqPart,1,1]];
Return[myqPart];
];

(* Simplify a qPart to its canonical form via "qPart expression" *)
SimplifyqPart[qPart_]:=Module[{myexpr,myqPart},
myexpr=ExprqPart[qPart];
myqPart=qPartFromExpr[myexpr];
Return[myqPart];
];

(* Simplify a qSec to its canonical form via "qPart expression" *)
SimplifyqSec[qSec_]:=Module[{qSecexpr,exprArray,myqSec},
qSecexpr=Plus@@(ExprqPart[#]&/@qSec);
exprArray=Flatten[{qSecexpr/.Plus->List}];
myqSec=qPartFromExpr[#]&/@exprArray;
Return[myqSec];
];

(* Scale a qSec by a constant coeff, which does not depend on q or dq *)
ScaleqSec[qSec_,coeff_]:=Module[{myqSec},
myqSec=Insert[#,coeff,1]&/@qSec;
myqSec=SimplifyqPart[#]&/@myqSec;
Return[myqSec];
];

(* Multiply a list of qSecs into a qSec *)
MultiplyqSecs[qSeclist_]:=Module[{myqSec},
myqSec=Flatten/@Tuples[qSeclist];
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];


(* ::Subsubsection::Closed:: *)
(*Derivatives and Integrals*)


(* ::Input::Initialization:: *)
Clear[dqCommRules];
Clear[dqLastqPart];
Clear[dqLastqSec];
Clear[dqAllqPart];
Clear[dqAllqSec];

Clear[\[Eta]ContractionRules];
Clear[qContractionRules];
Clear[AllPairings];
Clear[LoopInt];
Clear[SymHardqPart];
Clear[SymHardqSec];
Clear[IntegrateqPart];
Clear[IntegrateqSec];


(* ::Input::Initialization:: *)
(* Replacement rules for dq commutators *)
dqCommRules={{Subscript[dq, \[Mu]_],_?NumericQ}->{0},{Subscript[dq, \[Mu]_],Subscript[\[Eta], __]}->{0},{Subscript[dq, \[Mu]_],Subscript[m, __]}->{0},{Subscript[dq, \[Mu]_],Subscript[q, \[Nu]_]}->{Subscript[\[Eta], \[Mu],\[Nu]]},{Subscript[dq, \[Mu]_],Subscript[\[CapitalDelta], m_]}->{-2,Subscript[q, \[Mu]],\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(m\), \(2\)]\)},{Subscript[dq, \[Mu]_],\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(m_\), \(n_\)]\)}->{-2n,Subscript[q, \[Mu]],\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(m\), \(n + 1\)]\)}};

(* Carry out the last dq in a qPart to obtain a qSec *)
dqLastqPart[qPart_]:=Module[{myqPart,poslist,pos,myqSec},
myqPart=SimplifyqPart[qPart];
poslist=Flatten[Position[myqPart,Subscript[dq, __]]];
(* return when there is no dq to carry out *)
If[Length[poslist]==0,
	myqSec={myqPart};
	Return[myqSec];
];
pos=Last[poslist];
(* write qPart into a series of dq commutators *)
myqSec=Join[myqPart[[;;pos-1]],myqPart[[pos+1;;#-1]],{{myqPart[[pos]],myqPart[[#]]}},myqPart[[#+1;;]]]&/@Range[pos+1,Length[myqPart]];
(* carry out the dq commutators *)
myqSec=Flatten/@(myqSec/.dqCommRules);
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];

(* Carry out the last dq in a qSec to obtain a qSec *)
dqLastqSec[qSec_]:=Module[{myqSec},
myqSec=SimplifyqSec[qSec];
myqSec=Flatten[dqLastqPart/@myqSec,1];
Return[myqSec];
];

(* Carry out all dq in a qPart to obtain a qSec *)
dqAllqPart[qPart_]:=Module[{ii,ndq,myqSec},
ndq=Count[qPart,Subscript[dq, __]];
myqSec={qPart};
myqSec=Nest[dqLastqSec,myqSec,ndq];
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];

(* Carry out all dq in a qSec to obtain a qSec *)
dqAllqSec[qSec_]:=Module[{myqSec},
myqSec=Flatten[dqAllqPart/@qSec,1];
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];

(* \[Eta] contraction rules *)
\[Eta]ContractionRules={Subscript[\[Eta], \[Mu]_,\[Nu]_] Subscript[\[Eta], \[Mu]_,\[Rho]_]->Subscript[\[Eta], \[Nu],\[Rho]],Subscript[\[Eta], \[Mu]_,\[Nu]_] Subscript[\[Eta], \[Rho]_,\[Mu]_]->Subscript[\[Eta], \[Nu],\[Rho]],Subscript[\[Eta], \[Nu]_,\[Mu]_] Subscript[\[Eta], \[Mu]_,\[Rho]_]->Subscript[\[Eta], \[Nu],\[Rho]],Subscript[\[Eta], \[Nu]_,\[Mu]_] Subscript[\[Eta], \[Rho]_,\[Mu]_]->Subscript[\[Eta], \[Nu],\[Rho]],Subscript[\[Eta], \[Mu]_,\[Mu]_]->d,\!\(
\*SubsuperscriptBox[\(\[Eta]\), \(__\), \(2\)] -> d\),Subscript[a__, \[Mu]_] Subscript[\[Eta], \[Mu]_,\[Nu]_]->Subscript[a, \[Nu]],Subscript[a__, \[Mu]_] Subscript[\[Eta], \[Nu]_,\[Mu]_]->Subscript[a, \[Nu]],Subscript[a_, \[Mu]_,\[Nu]_,\[Rho]_,\[Sigma]_] Subscript[\[Eta], \[Mu]_,\[Alpha]_]->Subscript[a, \[Alpha],\[Nu],\[Rho],\[Sigma]],Subscript[a_, \[Mu]_,\[Nu]_,\[Rho]_,\[Sigma]_] Subscript[\[Eta], \[Alpha]_,\[Mu]_]->Subscript[a, \[Alpha],\[Nu],\[Rho],\[Sigma]],Subscript[a_, \[Nu]_,\[Mu]_,\[Rho]_,\[Sigma]_] Subscript[\[Eta], \[Mu]_,\[Alpha]_]->Subscript[a, \[Nu],\[Alpha],\[Rho],\[Sigma]],Subscript[a_, \[Nu]_,\[Mu]_,\[Rho]_,\[Sigma]_] Subscript[\[Eta], \[Alpha]_,\[Mu]_]->Subscript[a, \[Nu],\[Alpha],\[Rho],\[Sigma]],Subscript[a_, \[Nu]_,\[Rho]_,\[Mu]_,\[Sigma]_] Subscript[\[Eta], \[Mu]_,\[Alpha]_]->Subscript[a, \[Nu],\[Rho],\[Alpha],\[Sigma]],Subscript[a_, \[Nu]_,\[Rho]_,\[Mu]_,\[Sigma]_] Subscript[\[Eta], \[Alpha]_,\[Mu]_]->Subscript[a, \[Nu],\[Rho],\[Alpha],\[Sigma]],Subscript[a_, \[Nu]_,\[Rho]_,\[Sigma]_,\[Mu]_] Subscript[\[Eta], \[Mu]_,\[Alpha]_]->Subscript[a, \[Nu],\[Rho],\[Sigma],\[Alpha]],Subscript[a_, \[Nu]_,\[Rho]_,\[Sigma]_,\[Mu]_] Subscript[\[Eta], \[Alpha]_,\[Mu]_]->Subscript[a, \[Nu],\[Rho],\[Sigma],\[Alpha]]};

(* q contraction rules *)
qContractionRules={\!\(
\*SubsuperscriptBox[\(q\), \(__\), \(2\)] -> 
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(-1\)]\)};

(* Get the list of all pairings for an even number of objects *)
AllPairings[{}]:={{}};
AllPairings[{a_,b_}]:={{{a,b}}};
AllPairings[{a_,b__}]:=Flatten[Table[Prepend[{a,{b}[[i]]}]/@AllPairings[Delete[{b},i]],{i,Length[{b}]}],1];

(* A generic Loop Integral evaluated with dim-reg and MSbar scheme, multiplied by 16\[Pi]^2 *)
LoopInt[r_,nlist_,masslist_,coeff_]:=Module[{nlen,n,M,n1,n2,M1,M2,myResult},
nlen=Length[nlist];
If[nlen==0,Return[0]];
If[nlen==1,
	n=First[nlist];M=First[masslist];
	(* dim-reg *)
	myResult=coeff 1/(4\[Pi])^(d/2-2) (-1)^(n-r)/(M^2)^(n-r-d/2) Gamma[r+d/2]/Gamma[d/2] Gamma[n-r-d/2]/Gamma[n];
	(* MSbar scheme *)
	myResult=SeriesCoefficient[1/((4\[Pi])^\[Epsilon] Gamma[1+\[Epsilon]]) (myResult/.{d->4-2\[Epsilon]}),{\[Epsilon],0,0}];
	Return[myResult];
];
If[nlen==2,
	n1=nlist[[1]];n2=nlist[[2]];M1=masslist[[1]];M2=masslist[[2]];
	(* dim-reg *)
	myResult=coeff 1/(4\[Pi])^(d/2-2) (-1)^(n1+n2-r)/(M1^2)^(n1+n2-r-d/2) Gamma[r+d/2]/Gamma[d/2] Gamma[n1+n2-r-d/2]/Gamma[n1+n2];
	myResult=myResult*Hypergeometric2F1[n1+n2-r-d/2,n2,n1+n2,1-M2^2/M1^2];
	(* MSbar scheme *)
	myResult=SeriesCoefficient[1/((4\[Pi])^\[Epsilon] Gamma[1+\[Epsilon]]) (myResult/.{d->4-2\[Epsilon]}),{\[Epsilon],0,0}];
	Return[myResult];
];
myResult=Subsuperscript[LoopI,Row[Join[{"("},Riffle[nlist,","],{")"}]],Row[{"(",r,")"}]];
myResult=coeff Row[Join[{myResult,"("},{Row[masslist^2,","]},{")"}]];
Return[myResult];
];

(* Symmetrize qPart and expand in hard region to get a qSec before performing the q integral *)
SymHardqPart[qPart_,Heavylist_,LightOrd_]:=Module[{q\[Mu]list,\[CapitalDelta]list,coeff,npair,\[Eta]listArray,Mpattern,\[CapitalDelta]Mexpr,\[CapitalDelta]mexpr,\[CapitalDelta]Expr,\[CapitalDelta]listArray,myqSec},
(* split the qPart into three factors: q\[Mu]lsit, \[CapitalDelta]list, and "coeff" which is the product of the rest *)
q\[Mu]list=Cases[qPart,Subscript[q, \[Mu]_]->\[Mu]];
\[CapitalDelta]list=Cases[qPart,Subscript[\[CapitalDelta], __]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(__\), \(__\)]\)|Subscript[m, __]|\!\(\*SubsuperscriptBox[\(m\), \(__\), \(__\)]\)];
coeff=Times@@DeleteCases[qPart,Subscript[q, __]|Subscript[\[CapitalDelta], __]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(__\), \(__\)]\)|Subscript[m, __]|\!\(\*SubsuperscriptBox[\(m\), \(__\), \(__\)]\)];
(* convert q\[Mu]lsit into Subscript[\[CapitalDelta], 0], Subscript[\[Eta], \[Mu]\[Nu]], and Subscript[cp, n]=1/(d(d+2)...(d+2n-2)) for n pair of Subscript[q, \[Mu]] *)
npair=Length[q\[Mu]list]/2;
\[CapitalDelta]list=Join[\[CapitalDelta]list,{\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(-npair\)]\)}];
\[Eta]listArray=((Subscript[\[Eta],#]&/@#)/.{\!\(\*SubscriptBox[\(\[Eta]\), \({a__}\)]\)->Subscript[\[Eta], a]})&/@AllPairings[q\[Mu]list];
(* expand and truncate \[CapitalDelta]Part expression according to the given Heavylist and desired LightOrd *)
Mpattern=Alternatives@@(Join@@({Subscript[m, #],\!\(\*SubsuperscriptBox[\(m\), \(#\), \(__\)]\),Subscript[\[CapitalDelta], #],\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(#\), \(__\)]\)}&/@Heavylist));
\[CapitalDelta]Mexpr=Times@@Cases[\[CapitalDelta]list,Mpattern];
\[CapitalDelta]mexpr=Times@@(DeleteCases[\[CapitalDelta]list,Mpattern]/.{Subscript[\[CapitalDelta], i_]:>If[i==0,Subscript[\[CapitalDelta], i],Subscript[\[CapitalDelta], 0] 1/(1-Subscript[\[CapitalDelta], 0] \!\(\*SubsuperscriptBox[\(m\), \(i\), \(2\)]\))]});
\[CapitalDelta]Expr=Expand[\[CapitalDelta]Mexpr*(Normal[Series[\[CapitalDelta]mexpr/.{Subscript[m, i_]->Subscript[m, i]\[Epsilon]},{\[Epsilon],0,LightOrd}]]/.{\[Epsilon]->1})];
(* combine coeff, Subscript[cp, npair], and the truncated \[CapitalDelta]Part expression into the new qSec *)
\[CapitalDelta]listArray=Flatten[{#/.{Times->List}}]&/@Flatten[{\[CapitalDelta]Expr/.{Plus->List}}];
myqSec=Join[{coeff,Subscript[cp, npair]},#]&/@(Flatten/@Tuples[{\[Eta]listArray,\[CapitalDelta]listArray}]);
Return[myqSec];
];

(* Symmetrize a qSec and expand in hard region before performing the q integral *)
SymHardqSec[qSec_,Heavylist_,LightOrd_]:=Module[{myqSec},
myqSec=Join@@(SymHardqPart[#,Heavylist,LightOrd]&/@qSec);
myqSec=SimplifyqSec[myqSec];
Return[myqSec];
];

(* Carry out the q integral for a qPart *)
IntegrateqPart[qPart_]:=Module[{coeff,\[CapitalDelta]list,r,nlist,masslist,LoopIparameters,myqPart},
coeff=Times@@DeleteCases[qPart,Subscript[\[CapitalDelta], __]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(__\), \(__\)]\)];
(* Subscript[cp, n]=1/(d(d+2)...(d+2n-2)) for n pair of Subscript[q, \[Mu]] *)
coeff=coeff/.{Subscript[cp, n_]:>Times@@(1/(d+2#-2)&/@Range[n])};
\[CapitalDelta]list=Cases[qPart,Subscript[\[CapitalDelta], __]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(__\), \(__\)]\)];
r=-Plus@@(Cases[\[CapitalDelta]list,Subscript[\[CapitalDelta], 0]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(__\)]\)]/.{Subscript[\[CapitalDelta], 0]->1,\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(a_\)] -> a\)});
LoopIparameters=Transpose[DeleteCases[\[CapitalDelta]list,Subscript[\[CapitalDelta], 0]|\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(0\), \(__\)]\)]/.{Subscript[\[CapitalDelta], i_]->{i,1},\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i_\), \(n_\)] -> \({i, n}\)\)}];
masslist=Subscript[m, #]&/@LoopIparameters[[1]];
nlist=LoopIparameters[[2]];
If[Length[nlist]<3,
	(* store the result as {result}, when there are two or less heavy masses *)
	myqPart={LoopInt[r,nlist,masslist,coeff]},
	(* store the result as {coeff, LoopI}, when there are three or more heavy masses *)
	myqPart={coeff,LoopInt[r,nlist,masslist,1]};
];
Return[myqPart];
];

(* Carry out the q integral for a qSec *)
IntegrateqSec[qSec_]:=Module[{len,myqSec},
myqSec=IntegrateqPart/@qSec;
If[myqSec==={},myqSec={{0}}];
If[Length[myqSec[[1]]]<2,myqSec={{Simplify[Plus@@Flatten[myqSec]]}}];
Return[myqSec];
];


(* ::Subsection::Closed:: *)
(*Polynomial Manipulations*)


(* ::Text::Closed:: *)
(*Descriptions*)


(* ::Input::Initialization:: *)
(*
"poly" and "term" are used to handle the CDE procedure;

A "poly" is a list of "terms", while a "term" consists of three lists
term={qSec, Oper, Ord};
for example
UCDEDim[4]\[LeftDoubleBracket]1\[RightDoubleBracket]={{{1/6,Subscript[dq, Subscript[\[Mu], 1]],Subscript[dq, Subscript[\[Mu], 2]],Subscript[dq, Subscript[\[Mu], 3]]}},{{Subscript[P, Subscript[\[Mu], 1]],Subscript[P, Subscript[\[Mu], 2]],Subscript[P, Subscript[\[Mu], 3]],U}},{4,3}};
  GCDEDim[{Subscript[\[Nu], 1],Subscript[\[Nu], 2]},4]\[LeftDoubleBracket]1\[RightDoubleBracket]={{{-(\[ImaginaryI]/8),Subscript[dq, Subscript[\[Mu], 1]],Subscript[dq, Subscript[\[Mu], 2]]}},{{Subscript[P, Subscript[\[Mu], 1]],Subscript[P, Subscript[\[Mu], 2]],Subscript[F, Subscript[\[Nu], 1],Subscript[\[Nu], 2]]}},{4,2}};
The first list "qSec" is the q-Section of the term. This part will be integrated over eventually;
The second list "Oper" stores the effective operator. This part will be shown in the final result;The third list "Ord" consists of two auxiliary parameters
Ord={dim, ndummy};
respectively, they are;
dim      the operator dimension;
ndummy   the number of dummy Lorentz index pairs (Subscript[\[Mu], i] indices);

The numbers of dummy Lorentz indices, "ndummy", is only used in the steps of generating the CDE poly;
Once we obtain the poly and move on to address the loop integral (see the main function SuperTrace[] below), it will no longer be in use. In the final output, it will be discarded, and only "dim" will be kept.
*)


(* ::Subsubsection::Closed:: *)
(*Term and Poly Arithmetic*)


(* ::Input::Initialization:: *)
Clear[CollectPoly];
Clear[SimplifyPoly];
Clear[MultiplyTerms];
Clear[MultiplyPolys];


(* ::Input::Initialization:: *)
(* Collect terms with identical Oper and Ord in a poly *)
CollectPoly[poly_]:=Module[{mypoly},
(* collect terms with identical Oper and Ord *)
mypoly=ReplacePart[#[[1]],1->Join@@(#[[1]]&/@#)]&/@GatherBy[poly,{#[[2]],#[[3]]}&];
(* simplify qSec *)
mypoly=ReplacePart[#,1->SimplifyqSec[#[[1]]]]&/@mypoly;
mypoly=Select[mypoly,#[[1]]=!={{0}}&];
(* sort poly *)
mypoly=SortBy[mypoly,#[[3]][[1]]&];
Return[mypoly];
];

(* Simplify a poly by collecting and simplifying its terms *)
SimplifyPoly[poly_]:=Module[{qSecArray,OperArray,mypoly},
(* move all commuting factors including constants, Subscript[m, i], Subscript[\[Eta], \[Mu]\[Nu]], and Subscript[\[CurlyEpsilon], \[Mu]\[Nu]\[Rho]\[Sigma]] in Oper to qSec *)
qSecArray=ScaleqSec[#[[1]],Times@@Cases[Flatten[#[[2]]],_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[CurlyEpsilon], __]]]&/@poly;
OperArray=Select[DeleteCases[#,_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[CurlyEpsilon], __]]&/@#[[2]],(#=!={})&]&/@poly;
mypoly=MapThread[ReplacePart[#3,{1->#1,2->#2}]&,{qSecArray,OperArray,poly}];
(* collect terms with identical Oper *)
mypoly=ReplacePart[#[[1]],1->Join@@(#[[1]]&/@#)]&/@GatherBy[mypoly,#[[2]]&];
(* simplify qSec *)
mypoly=ReplacePart[#,1->SimplifyqSec[#[[1]]]]&/@mypoly;
mypoly=Select[mypoly,#[[1]]=!={{0}}&];
(* sort poly *)
mypoly=SortBy[mypoly,#[[3]][[1]]&];
Return[mypoly];
];

(* Multiply a list of terms into a term *)
MultiplyTerms[termArray_]:=Module[{dummyshiftArray,mytermArray,qSec,Oper,Ord,indices,indicesOpen,indicesDummy,ndummy,n\[Mu],myterm},
(* distinguish dummy indices Subscript[\[Mu], i] before multiplying terms *)
dummyshiftArray=Join[{0},Accumulate[(#[[3]][[2]])&/@termArray][[;;-2]]];
mytermArray=MapThread[#1/.{Subscript[\[Mu], n_]->Subscript[\[Mu], n+#2]}&,{termArray,dummyshiftArray}];
(* multiply terms *)
qSec=MultiplyqSecs[#[[1]]&/@mytermArray];
Oper=Join@@(#[[2]]&/@mytermArray);
Ord=Plus@@(#[[3]]&/@mytermArray);
myterm={qSec,Oper,Ord};
(* convert new dummy Lorentz indices into Subscript[\[Mu], i] *)
n\[Mu]=Ord[[2]];
indices=DeleteCases[Cases[Join[qSec[[1]],Flatten[Oper]],Subscript[_, a__]->a],_?NumericQ|Subscript[\[Mu], _]];
indicesOpen=Select[indices,(Count[indices,#]==1)&];
If[Count[indicesOpen,Subscript[\[Mu], _]]>0,
Print["MultiplyTerms called with term containing open \!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\) indices: term=",myterm];
Print["Aborted."];
Abort[];
];
indicesDummy=DeleteDuplicates[Select[indices,(Count[indices,#]>1)&]];
ndummy=Length[indicesDummy];
myterm=myterm/.MapThread[(#1->Subscript[\[Mu], n\[Mu]+#2])&,{indicesDummy,Range[ndummy]}];
myterm[[3]][[2]]=n\[Mu]+ndummy;
Return[myterm];
];

(* Multiply a list of polys into a poly *)
MultiplyPolys[polyArray_]:=Module[{mypoly},
mypoly=MultiplyTerms/@Tuples[polyArray];
mypoly=CollectPoly[mypoly];
Return[mypoly];
];


(* ::Subsubsection::Closed:: *)
(*Trimmings*)


(* ::Input::Initialization:: *)
Clear[qPartFVanish];
Clear[FTrimqSec];
Clear[FTrimTerm];
Clear[FTrimPoly];
Clear[qEvenTrimPoly];

Clear[IBPTerm];
Clear[IBPPoly];
Clear[IBPAllTerm];
Clear[IBPAllPoly];
Clear[\[Eta]pairTerm];
Clear[MoveLorentzTerm];
Clear[FIndexOrgOper];
Clear[OperIndexOrgTerm];
Clear[PPFpattern0];
Clear[PPFpattern1];
Clear[PPFrules1];
Clear[FUrules];
Clear[PPFOrgTerm];
Clear[FUOrgTerm];
Clear[All\[Gamma]Pairings];
Clear[Trace\[Gamma]Term];


(* ::Input::Initialization:: *)
(* Check if a qPart vanishes upon contracting with a given Subscript[F, \[Mu]\[Nu]] *)
qPartFVanish[qPart_,F\[Mu]pair_]:=Module[{myqPartSplit,q\[Mu]listArray,dq\[Mu]listArray,\[Eta]\[Mu]pairlist},
myqPartSplit=SplitqPart[qPart];
(* check if qPart vanishes due to Subscript[q, \[Mu]]Subscript[q, \[Nu]] *)
q\[Mu]listArray=Cases[#,Subscript[q, sub__]->sub]&/@myqPartSplit;
If[Or@@(SubsetQ[#,F\[Mu]pair]&/@q\[Mu]listArray),Return[True]];
(* check if qPart vanishes due to Subscript[dq, \[Mu]]Subscript[dq, \[Nu]] *)
dq\[Mu]listArray=Cases[#,Subscript[dq, sub__]->sub]&/@myqPartSplit;
If[Or@@(SubsetQ[#,F\[Mu]pair]&/@dq\[Mu]listArray),Return[True]];
(* check if qPart vanishes due to Subscript[\[Eta], \[Mu]\[Nu]] *)
\[Eta]\[Mu]pairlist=Cases[qPart,Subscript[\[Eta], sub__]->{sub}];
If[MemberQ[\[Eta]\[Mu]pairlist,F\[Mu]pair]||MemberQ[\[Eta]\[Mu]pairlist,Reverse[F\[Mu]pair]],Return[True]];
Return[False];
];

(* FTrim a qSec *)
FTrimqSec[qSec_,F\[Mu]pair_]:=Module[{myqSec},
myqSec=Select[qSec,!qPartFVanish[#,F\[Mu]pair]&];
If[myqSec==={},myqSec={{0}}];
Return[myqSec];
];

(* FTrim a term *)
FTrimTerm[term_]:=Module[{F\[Mu]pairlist,myqSec,myterm},
F\[Mu]pairlist=Cases[Flatten[term[[2]]],Subscript[F, a__]->{a}];
myqSec=Fold[FTrimqSec,term[[1]],F\[Mu]pairlist];
myterm=ReplacePart[term,1->myqSec];
Return[myterm];
];

(* FTrim a poly *)
FTrimPoly[poly_]:=Module[{mypoly},
mypoly=FTrimTerm/@poly;
mypoly=Select[mypoly,#[[1]]=!={{0}}&];
Return[mypoly];
];

(* Trim a poly by keeping only even parts under q\[Rule]-q *)
qEvenTrimPoly[poly_]:=Module[{mypoly},
mypoly=ReplacePart[#,1->Select[#[[1]],EvenQ[Count[#,Subscript[q, __]]+Count[#,Subscript[dq, __]]]&]]&/@poly;
mypoly=Select[mypoly,#[[1]]=!={}&];
Return[mypoly];
];

(* Use IBP on a term to remove one Subscript[P, \[Mu]] on the last factor in Oper to get a poly *)
IBPTerm[term_]:=Module[{myOper,len,myOperArray,mypoly},
myOper=term[[2]];
len=Length[myOper];
If[len<2,Return[{term}]];
If[!MatchQ[myOper[[-1]][[1]],Subscript[P, __]],Return[{term}]];
myOperArray=ReplacePart[myOper,{#->Join[{-1, myOper[[-1]][[1]]},myOper[[#]]],-1->Delete[myOper[[-1]],1]}]&/@Range[len-1];
mypoly=ReplacePart[term,2->#]&/@myOperArray;
Return[mypoly];
];

(* Use IBP on a poly to remove one Subscript[P, \[Mu]] on the last factor in Oper *)
IBPPoly[poly_]:=Module[{mypoly},
mypoly=Join@@(IBPTerm/@poly);
Return[mypoly];
];

(* Use IBP on a term to remove all Subscript[P, \[Mu]] on the last factor in Oper to get a poly *)
IBPAllTerm[term_]:=Module[{nIBP,mypoly},
nIBP=Count[term[[2]][[-1]],Subscript[P, __]];
mypoly={term};
mypoly=Nest[IBPPoly,mypoly,nIBP];
Return[mypoly];
];

(* Use IBP on a poly to move all Subscript[P, \[Mu]] on the last factor in Oper *)
IBPAllPoly[poly_]:=Module[{mypoly},
mypoly=Join@@(IBPAllTerm/@poly);
Return[mypoly];
];

(* Contract a term with an Subscript[\[Eta], \[Mu]\[Nu]] *)
\[Eta]pairTerm[term_,\[Eta]pair_]:=Module[{myOper,myterm},
myOper=term[[2]];
If[Count[myOper,\[Eta]pair[[2]],All]==1,
myOper=myOper/.{\[Eta]pair[[2]]->\[Eta]pair[[1]]},
If[Count[myOper,\[Eta]pair[[1]],All]==1,
myOper=myOper/.{\[Eta]pair[[1]]->\[Eta]pair[[2]]},
myOper=Join[{{Subscript[\[Eta], \[Eta]pair]}},myOper]/.{\!\(\*SubscriptBox[\(\[Eta]\), \({a__}\)]\)->Subscript[\[Eta], a]};
];
];
myterm=ReplacePart[term,2->myOper];
Return[myterm];
];

(* Move Subscript[\[Eta], \[Mu]\[Nu]] and Subscript[\[CurlyEpsilon], \[Mu]\[Nu]\[Rho]\[Sigma]] in the qSec of a term to the Oper to get a poly *)
MoveLorentzTerm[term_]:=Module[{myqSec,\[Eta]pairsArray,\[CurlyEpsilon]listArray,qSecArray,OperArray,mypoly},
myqSec=SimplifyqSec[term[[1]]]; If[myqSec==={{0}},Return[{}]];
(* move Subscript[\[Eta], \[Mu]\[Nu]] *)
mypoly=ReplacePart[term,1->#]&/@({DeleteCases[#,Subscript[\[Eta], __]]}&/@myqSec);
\[Eta]pairsArray=Cases[#,Subscript[\[Eta], a__]->{a}]&/@myqSec;
mypoly=MapThread[Fold[\[Eta]pairTerm,#1,#2]&,{mypoly,\[Eta]pairsArray}];
mypoly=Select[mypoly,Count[#[[2]],{Subscript[F, \[Mu]_,\[Mu]_]}|{__,Subscript[F, \[Mu]_,\[Mu]_]}]==0&];
(* move Subscript[\[CurlyEpsilon], \[Mu]\[Nu]\[Rho]\[Sigma]] *)
\[CurlyEpsilon]listArray=Cases[#[[1]][[1]],Subscript[\[CurlyEpsilon], __]]&/@mypoly;
qSecArray={DeleteCases[#[[1]][[1]],Subscript[\[CurlyEpsilon], __]]}&/@mypoly;
OperArray=MapThread[If[#2==={},#1[[2]],Join[#1[[2]],{#2}]]&,{mypoly,\[CurlyEpsilon]listArray}];
mypoly=MapThread[ReplacePart[#3,{1->#1,2->#2}]&,{qSecArray,OperArray,mypoly}];
Return[mypoly];
];

(* Organize the indices of the nth Subscript[F, \[Mu]\[Nu]] in an Oper *)
FIndexOrgOper[oper_,n_]:=Module[{mylist,partNolist,partNo,\[Mu]pair,indices,dummyindices,\[Mu]pairother,myOper},
mylist=Flatten[oper];
partNolist=Join@@(Tuples[{{#},Range[Length[oper[[#]]]]}]&/@Range[Length[oper]]);
partNo=Cases[partNolist,_?(MatchQ[oper[[#[[1]]]][[#[[2]]]],Subscript[F, __]]&)][[n]];
\[Mu]pair=Cases[mylist,Subscript[F, a__]->{a}][[n]];
indices=DeleteCases[Cases[mylist,Subscript[_, a__]->a],_?NumericQ];
dummyindices=DeleteDuplicates[Select[indices,Count[indices,#]>1&]];
(* if \[Mu]pair are not both dummy indices, put indices in Subscript[F, \[Mu]\[Nu]] in canonical order using its antisymmetry *)
If[!SubsetQ[dummyindices,\[Mu]pair],
If[Sort[\[Mu]pair]===\[Mu]pair,Return[oper]];
myOper=Flatten/@(ReplacePart[oper,partNo->{-1,Subscript[F, Reverse[\[Mu]pair]]}]/.{\!\(\*SubscriptBox[\(F\), \({a__}\)]\)->Subscript[F, a]});
Return[myOper];
];
(* if \[Mu]pair are both dummy indices, canonically order both dummy indices *)
\[Mu]pairother=Cases[Cases[Flatten[Delete[oper,partNo]],Subscript[_, a__]->a],_?(MemberQ[\[Mu]pair,#]&)];
If[\[Mu]pair===\[Mu]pairother,Return[oper]];
If[Sort[\[Mu]pair]=!=\[Mu]pair,
myOper=Flatten/@(ReplacePart[oper,partNo->{-1,Subscript[F, Reverse[\[Mu]pair]]}]/.{\!\(\*SubscriptBox[\(F\), \({a__}\)]\)->Subscript[F, a]});
Return[myOper];
];
myOper=Flatten/@(ReplacePart[oper,partNo->{-1,Subscript[F, Reverse[\[Mu]pair]]}]/.{\!\(\*SubscriptBox[\(F\), \({a__}\)]\)->Subscript[F, a]});
myOper=myOper/.{\[Mu]pair[[1]]->\[Mu]pair[[2]],\[Mu]pair[[2]]->\[Mu]pair[[1]]};
Return[myOper];
];

(* Organize the indices of Oper in a term *)
OperIndexOrgTerm[term_]:=Module[{myOper,indices,dummyindices,openindices,Fpairs,ndummy,nopen,nF,myterm},
myOper=term[[2]];
(* extract indices in Oper *)
indices=DeleteCases[Cases[Flatten[myOper],Subscript[_, a__]->a],_?NumericQ];
dummyindices=DeleteDuplicates[Select[indices,Count[indices,#]>1&]];
openindices=DeleteCases[indices,_?(Count[indices,#]>1&)];
ndummy=Length[dummyindices];
nopen=Length[openindices];
If[Cases[openindices,Subscript[\[Mu], _]]=!={},
Print["OperIndexOrgTerm called with open indices containing \!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\)."];
Print["open indices=",openindices];
Print["term=",term];
Print["Aborted."];
Abort[];
];
(* canonically order dummy indices *)
myterm=term/.MapThread[#1->Subscript[\[Mu], #2]&,{dummyindices,Range[ndummy]}];
(* canonically order Subscript[F, \[Mu]\[Nu]] indices *)
myOper=myterm[[2]];
nF=Count[myOper,Subscript[F, __],All];
myOper=Fold[FIndexOrgOper,myOper,Range[nF]];
myterm=ReplacePart[myterm,2->myOper];
(* canonically order Subscript[\[CurlyEpsilon], \[Mu]\[Nu]\[Rho]\[Sigma]] indices *)
myOper=Flatten[#/.{Subscript[\[CurlyEpsilon], a__]:>{Signature[{a}],Subscript[\[CurlyEpsilon], Sort[{a}]]}}/.{\!\(\*SubscriptBox[\(\[CurlyEpsilon]\), \({a__}\)]\)->Subscript[\[CurlyEpsilon], a]}]&/@myterm[[2]];
myterm=ReplacePart[myterm,2->myOper];
Return[myterm];
];

(* PPF paterns and their simplification rules *)
PPFpattern0=Alternatives@@{{Subscript[P, \[Mu]_],Subscript[P, \[Nu]_],Subscript[F, \[Mu]_,\[Nu]_]},{__,Subscript[P, \[Mu]_],Subscript[P, \[Nu]_],Subscript[F, \[Mu]_,\[Nu]_]},{Subscript[P, \[Mu]_],Subscript[P, \[Nu]_],Subscript[F, \[Nu]_,\[Mu]_]},{__,Subscript[P, \[Mu]_],Subscript[P, \[Nu]_],Subscript[F, \[Nu]_,\[Mu]_]}};
PPFpattern1=Alternatives@@{{Subscript[P, \[Rho]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]},{__,Subscript[P, \[Rho]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]},{Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]},{__,Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]},{Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Nu]_,\[Mu]_]},{__,Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Nu]_,\[Mu]_]}};
PPFrules1={{Subscript[P, \[Rho]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]}->{{Subscript[P, \[Mu]],Subscript[P, \[Rho]],Subscript[F, \[Rho],\[Nu]]},{I,Subscript[F, \[Rho],\[Mu]],Subscript[F, \[Rho],\[Nu]]},{-1,Subscript[P, \[Nu]],Subscript[P, \[Rho]],Subscript[F, \[Rho],\[Mu]]},{-I,Subscript[F, \[Rho],\[Nu]],Subscript[F, \[Rho],\[Mu]]}},
{a__,Subscript[P, \[Rho]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]}->{{a,Subscript[P, \[Mu]],Subscript[P, \[Rho]],Subscript[F, \[Rho],\[Nu]]},{a,I,Subscript[F, \[Rho],\[Mu]],Subscript[F, \[Rho],\[Nu]]},{a,-1,Subscript[P, \[Nu]],Subscript[P, \[Rho]],Subscript[F, \[Rho],\[Mu]]},{a,-I,Subscript[F, \[Rho],\[Nu]],Subscript[F, \[Rho],\[Mu]]}},
{Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]}->{{Subscript[P, \[Rho]],Subscript[P, \[Mu]],Subscript[F, \[Mu],\[Nu]]},{I,Subscript[F, \[Mu],\[Rho]],Subscript[F, \[Mu],\[Nu]]}},{a__,Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Nu]_,\[Mu]_]}->{{a,Subscript[P, \[Rho]],Subscript[P, \[Mu]],Subscript[F, \[Nu],\[Mu]]},{a,I,Subscript[F, \[Mu],\[Rho]],Subscript[F, \[Nu],\[Mu]]}},
{Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Nu]_,\[Mu]_]}->{{Subscript[P, \[Rho]],Subscript[P, \[Mu]],Subscript[F, \[Nu],\[Mu]]},{I,Subscript[F, \[Mu],\[Rho]],Subscript[F, \[Nu],\[Mu]]}},{a__,Subscript[P, \[Mu]_],Subscript[P, \[Rho]_],Subscript[F, \[Mu]_,\[Nu]_]}->{{a,Subscript[P, \[Rho]],Subscript[P, \[Mu]],Subscript[F, \[Mu],\[Nu]]},{a,I,Subscript[F, \[Mu],\[Rho]],Subscript[F, \[Mu],\[Nu]]}}};
FUrules={{Subscript[F, a__],U__}->{{{Subscript[F, a]},{U}},{{U},{-1,Subscript[F, a]}}}};

(* Use PPF simplification rules on a term to get a poly *)
PPFOrgTerm[term_]:=Module[{operArray,mypoly},
If[Count[term[[2]],PPFpattern0]!= 0,Return[{}]];
operArray=Tuples[(If[MatchQ[#,PPFpattern1],#,{#}]&/@term[[2]])/.PPFrules1];
mypoly=ReplacePart[term,2->#]&/@operArray;
Return[mypoly];
];

(* Use FU simplification rules on a term to get a poly *)
FUOrgTerm[term_]:=Module[{operArray,mypoly},
operArray=Flatten[#,1]&/@Tuples[(If[MatchQ[#,{Subscript[F, __],__}],#,{{#}}]&/@term[[2]])/.FUrules];
mypoly=ReplacePart[term,2->#]&/@operArray;
Return[mypoly];
];

(* Get the \[Eta]expr from all \[Gamma] pairings (alternating pairings) of an even number of indices *)
All\[Gamma]Pairings[{}]:=1;
All\[Gamma]Pairings[{a_,b_}]:=Subscript[\[Eta], a,b];
All\[Gamma]Pairings[{a_,b__}]:=Sum[(-1)^(k-1) Subscript[\[Eta], a,{b}[[k]]]All\[Gamma]Pairings[Delete[{b},k]],{k,Length[{b}]}];

(* Simplify a term to get a poly when the Ulist has no \[Gamma] dependence *)
Trace\[Gamma]Term[term_]:=Module[{myOper,n\[Mu],\[Mu]starts,coeff,\[Gamma]\[Mu]list,\[Eta]expr,\[Eta]pairArray,coeffArray,mypoly},
myOper=term[[2]];
(* replace \[Sigma]F with Subscript[\[ImaginaryI]\[Gamma], \[Mu]]Subscript[\[Gamma], \[Nu]]Subscript[F, \[Mu]\[Nu]] *)
n\[Mu]=Max[Join[{0},Cases[Cases[Flatten[myOper],Subscript[_, a__]->a],Subscript[\[Mu], b_]->b]]];
\[Mu]starts=n\[Mu]+2*Join[{0},Accumulate[Count[#,\[Sigma]F]&/@myOper][[;;-2]]];
myOper=Flatten/@MapThread[#1/.{\[Sigma]F->{I,Subscript[\[Gamma], Subscript[\[Mu], #2+1]],Subscript[\[Gamma], Subscript[\[Mu], #2+2]],Subscript[F, Subscript[\[Mu], #2+1],Subscript[\[Mu], #2+2]]}}&,{myOper,\[Mu]starts}];
(* extract constants and \[Gamma], and carry out trace of \[Gamma] *)
coeff=Times@@Cases[Flatten[myOper],_?NumericQ];
\[Gamma]\[Mu]list=Cases[Cases[Flatten[myOper],Subscript[\[Gamma], __]],Subscript[_, a__]->a];
\[Eta]expr=coeff All\[Gamma]Pairings[\[Gamma]\[Mu]list]/.{Subscript[\[Eta], \[Mu]_,\[Mu]_]->d};
\[Eta]pairArray=(Flatten[{#/.{Times->List}}])&/@Flatten[{\[Eta]expr/.{Plus->List}}];
(* multiply \[Eta]expr with Oper to get a poly *)
coeffArray=(Times@@Cases[#,_?NumericQ|d])&/@\[Eta]pairArray;
myOper=DeleteCases[#,_?NumericQ|Subscript[\[Gamma], __]]&/@myOper;
mypoly=ReplacePart[term,{1->ScaleqSec[term[[1]],#],2->myOper}]&/@coeffArray;
\[Eta]pairArray=Cases[DeleteCases[#,_?NumericQ|d],Subscript[\[Eta], a__]->{a}]&/@\[Eta]pairArray;
mypoly=MapThread[Fold[\[Eta]pairTerm,#1,#2]&,{mypoly,\[Eta]pairArray}];
mypoly=Select[mypoly,Count[#[[2]],{Subscript[F, \[Mu]_,\[Mu]_]}|{__,Subscript[F, \[Mu]_,\[Mu]_]}]==0&];
Return[mypoly];
];


(* ::Subsubsection::Closed:: *)
(*Derivatives and Integrals*)


(* ::Input::Initialization:: *)
Clear[dqAllPoly];
Clear[SymHardTerm];
Clear[SymHardPoly];
Clear[IntegratePoly];


(* ::Input::Initialization:: *)
(* Carrying out all the dq derivatives in a poly *)
dqAllPoly[poly_]:=Module[{mypoly},
mypoly=ReplacePart[#,1->dqAllqSec[#[[1]]]]&/@poly;
Return[mypoly];
];

(* Symmetrize a term and expand in hard region before performing the q integral *)
SymHardTerm[term_,dim_,Heavylist_,SoftOrd_]:=Module[{myqSec,myexprArray,\[Eta]pairsArray,myterm},
(* contract all the Lorentz indices in qSec *)
myexprArray=(((Times@@#)//.\[Eta]ContractionRules)/.qContractionRules)&/@term[[1]];
myexprArray=myexprArray/.{Subscript[\[Eta], \[Mu]_,\[Nu]_]:>Subscript[\[Eta], Sort[{\[Mu],\[Nu]}]]}/.{\!\(\*SubscriptBox[\(\[Eta]\), \({a__}\)]\)->Subscript[\[Eta], a]};
myexprArray=myexprArray/.{Subscript[\[CurlyEpsilon], a__]:>Signature[{a}]Subscript[\[CurlyEpsilon], Sort[{a}]]}/.{\!\(\*SubscriptBox[\(\[CurlyEpsilon]\), \({a__}\)]\)->Subscript[\[CurlyEpsilon], a]};
myexprArray=Flatten[{(Plus@@myexprArray)/.Plus->List}];
myqSec=qPartFromExpr[#]&/@myexprArray;
(* FTrim the qSec *)
myqSec=FTrimTerm[ReplacePart[term,1->myqSec]][[1]];
If[myqSec==={{0}},Return[ReplacePart[term,1->myqSec]]];
(* symmetrize qSec and expand in hard region *)
myqSec=SymHardqSec[myqSec,Heavylist,dim-term[[3]][[1]]+SoftOrd];
myterm=ReplacePart[term,1->myqSec];
Return[myterm];
];

(* Symmetrize a poly, expand in hard region, and organize it before performing the q integral *)
SymHardPoly[poly_,dim_,Heavylist_,SoftOrd_,No\[Gamma]inU_]:=Module[{mypoly},
mypoly=IBPAllPoly[poly];
mypoly=SymHardTerm[#,dim,Heavylist,SoftOrd]&/@mypoly;
mypoly=SimplifyPoly[mypoly];
mypoly=Join@@(MoveLorentzTerm/@mypoly);
(* simplify the result when Ulist has no \[Gamma] dependence *)
If[No\[Gamma]inU,
(* delete terms with odd numbers of Subscript[\[Gamma], \[Mu]] or only one \[Sigma]F *)
mypoly=Select[mypoly,EvenQ[Count[#[[2]],Subscript[\[Gamma], __],All]]&];
mypoly=Select[mypoly,!((Count[#[[2]],Subscript[\[Gamma], __],All]==0)&&(Count[#[[2]],\[Sigma]F,All]==1))&];
(* carry out trace of \[Gamma] *)
mypoly=Join@@(Trace\[Gamma]Term/@mypoly);
];
(* organize and simplify *)
mypoly=OperIndexOrgTerm/@mypoly;
mypoly=SimplifyPoly[mypoly];
mypoly=Join@@(PPFOrgTerm/@mypoly);
mypoly=SimplifyPoly[mypoly];
mypoly=Join@@(FUOrgTerm/@mypoly);
mypoly=Join@@(MoveLorentzTerm/@mypoly);
mypoly=OperIndexOrgTerm/@mypoly;
mypoly=SimplifyPoly[mypoly];
Return[mypoly];
];

(* Carrying out the q integral of a poly *)
IntegratePoly[poly_]:=Module[{mypoly},
mypoly=ReplacePart[#,1->IntegrateqSec[#[[1]]]]&/@poly;
mypoly=Select[mypoly,#[[1]]=!={{0}}&];
Return[mypoly];
];


(* ::Subsection::Closed:: *)
(*CDE Quantities*)


(* ::Text::Closed:: *)
(*Descriptions*)


(* ::Input::Initialization:: *)
(*
The CDE quantities are defined below;

\!\(
\*SubsuperscriptBox[\(U\), \(i\), \(CDE\)] = \(\(
\*SubsuperscriptBox[\(\[Sum]\), \(n = 0\), \(\[Infinity]\)]
\*FractionBox[\(1\), \(n!\)]\((\(
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(n\)]]
\*SubscriptBox[\(U\), \(i\)])\)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(n\)]]\)\);

\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(i\)]
\*SubscriptBox[\(\[Nu]\), \(j\)]\), \(CDE\)] = \(\(\(-i\)\(
\*SubsuperscriptBox[\(\[Sum]\), \(n = 0\), \(\[Infinity]\)]
\*FractionBox[\(n + 1\), \(\((n + 2)\)!\)]\((\(
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(n\)]]
\*SubscriptBox[\(F\), \(
\*SubscriptBox[\(\[Nu]\), \(i\)]
\*SubscriptBox[\(\[Nu]\), \(j\)]\)])\)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(1\)]]\) ... \)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(n\)]]\)\);

\!\(
\*SubsuperscriptBox[\(P\), 
SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)] = \(\(-
\*SubscriptBox[\(q\), 
SubscriptBox[\(\[Nu]\), \(1\)]]\) + 
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(2\)]]\)\);

X^CDE=(Subscript[q, Subscript[\[Nu], 1]] Subsuperscript[G, Subscript[\[Nu], 1]Subscript[\[Nu], 2], CDE] + \!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]\ 
\*SubscriptBox[\(q\), 
SubscriptBox[\(\[Nu]\), \(1\)]]\))Subscript[dq, Subscript[\[Nu], 2]] - \!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]\ 
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(3\)]\), \(CDE\)]\ 
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(2\)]]\ 
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(3\)]]\);

\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)] = \(
\*FractionBox[\(1\), \(
\*SuperscriptBox[\(q\), \(2\)] - 
\*SubsuperscriptBox[\(m\), \(i\), \(2\)] - 
\*SuperscriptBox[\(X\), \(CDE\)]\)] = \(\(
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)] + 
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)]
\*SuperscriptBox[\(X\), \(CDE\)]
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)] + 
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)]
\*SuperscriptBox[\(X\), \(CDE\)]
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)]
\*SuperscriptBox[\(X\), \(CDE\)]
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)] +  ... \)\ \ \ with\ 
\*SubscriptBox[\(\[CapitalDelta]\), \(i\)] = 
\*FractionBox[\(1\), \(
\*SuperscriptBox[\(q\), \(2\)] - 
\*SubsuperscriptBox[\(m\), \(i\), \(2\)]\)]\)\)\);
*)


(* ::Subsubsection::Closed:: *)
(*\!\(\*SubsuperscriptBox[\(U\), \(i\), \(CDE\)]\) and \!\(\*SubsuperscriptBox[\(G\), \(\[Mu]\[Nu]\), \(CDE\)]\)*)


(* ::Input::Initialization:: *)
Clear[ConvertDummy];
Clear[UCDEDim];
Clear[GCDEDim];


(* ::Input::Initialization:: *)
(* Convert dummy indices in a list into Subscript[\[Mu], i] indices *)
ConvertDummy[list_,n\[Mu]_]:=Module[{indices,indicesOpen,indicesDummy,mylist},
indices=DeleteCases[Cases[list,Subscript[_, a__]->a],_?NumericQ];
indicesOpen=Select[indices,(Count[indices,#]==1)&];
If[Count[indicesOpen,Subscript[\[Mu], _]]>0,
Print["ConvertDummy called with list containing \!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\) open indices: list=",list];
Print["Aborted."];
Abort[];
];
indicesDummy=DeleteDuplicates[Select[indices,(Count[indices,#]>1)&]];
mylist=list/.MapThread[(#1->Subscript[\[Mu], n\[Mu]+#2])&,{indicesDummy,Range[Length[indicesDummy]]}];
Return[mylist];
];

(* Poly Subsuperscript[U, i, CDE]=\!\(
\*SubsuperscriptBox[\(\[Sum]\), \(n = 0\), \(\[Infinity]\)]\(
\*FractionBox[\(1\), \(n!\)]\((\(
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(n\)]]
\*SubscriptBox[\(U\), \(i\)])\)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(1\)]]\)\)...Subscript[dq, Subscript[\[Mu], n]] at a given operator dimension *)
UCDEDim[dim_,OptionsPattern[{Udim->1,Uoper->{}}]]:=Module[{Uexpr,n,coeff,UArray,qSec,OperArray,ndummyArray,mypoly},
Uexpr=OptionValue[Uoper];
If[Uexpr==={},Uexpr=U];
If[NumericQ[Uexpr],If[dim==0,Return[{{{{Uexpr}},{},{0,0}}}],Return[{}]]];
n=dim-OptionValue[Udim];
If[(!IntegerQ[n])||(n<0),Return[{}]];
coeff=1/n!;
qSec={Join[{coeff},Subscript[dq,Subscript[\[Mu],#]]&/@Range[n]]};
UArray=Flatten[{#/.{Times->List,NonCommutativeMultiply->List}}]&/@Flatten[{Uexpr/.Plus->List}];
OperArray={Join[Subscript[P,Subscript[\[Mu],#]]&/@Range[n],ConvertDummy[#,n]]}&/@UArray;
ndummyArray=n+(Count[Tally[DeleteCases[Cases[#,Subscript[_, a__]->a],_?NumericQ]],_?(#[[2]]>1&)]&/@UArray);
mypoly=MapThread[{qSec,#1,{dim,#2}}&,{OperArray,ndummyArray}];
Return[mypoly];
];

(* Poly Subsuperscript[G, Subscript[\[Nu], i]Subscript[\[Nu], j], CDE]=-i\!\(
\*SubsuperscriptBox[\(\[Sum]\), \(n = 0\), \(\[Infinity]\)]\(
\*FractionBox[\(n + 1\), \(\((n + 2)\)!\)]\((\(
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(n\)]]
\*SubscriptBox[\(F\), \(
\*SubscriptBox[\(\[Nu]\), \(i\)]
\*SubscriptBox[\(\[Nu]\), \(j\)]\)])\)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(1\)]]\)\)...Subscript[dq, Subscript[\[Mu], n]] at a given operator dimension *)
GCDEDim[{\[Nu]i_,\[Nu]j_},dim_]:=Module[{n,coeff,expr,qSec,Oper,mypoly},
If[MemberQ[{\[Nu]i,\[Nu]j},Subscript[\[Mu], _]],
Print["GCDEDim[] called with invalid input {\[Nu]i, \[Nu]j}=",{\[Nu]i,\[Nu]j}];
Print["\!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\) is reserved for dummy indices and cannot be used as open indices for GCDEDim[]."];
Print["Aborted."];
Abort[];
];
If[\[Nu]i===\[Nu]j,Return[{}]];
n=dim-2;
If[(!IntegerQ[n])||(n<0),Return[{}]];
coeff=-I (n+1)/(n+2)!;
qSec={Join[{coeff},Subscript[dq,Subscript[\[Mu],#]]&/@Range[n]]};
Oper={Join[Subscript[P,Subscript[\[Mu],#]]&/@Range[n],{Subscript[F,\[Nu]i,\[Nu]j]}]};
mypoly={{qSec,Oper,{dim,n}}};
Return[mypoly];
];


(* ::Subsubsection::Closed:: *)
(*\!\(\*SubsuperscriptBox[\(P\), \(\[Mu]\), \(CDE\)]\) and \!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\)*)


(* ::Input::Initialization:: *)
Clear[PCDEDim];
Clear[XCDEDim];
Clear[\[CapitalDelta]XStrDimPar];
Clear[\[CapitalDelta]XStrnX];
Clear[\[CapitalDelta]CDEDimGen];
Clear[Load\[CapitalDelta]CDEPolyCache];
Clear[\[CapitalDelta]CDEDim];


(* ::Input::Initialization:: *)
(* Poly Subsuperscript[P, Subscript[\[Nu], i], CDE]=-Subscript[q, Subscript[\[Nu], i]]+\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(i\)]\[Rho]\), \(CDE\)]
\*SubscriptBox[\(dq\), \(\[Rho]\)]\)=-Subscript[q, Subscript[\[Nu], i]]-i\!\(
\*SubsuperscriptBox[\(\[Sum]\), \(n = 0\), \(\[Infinity]\)]\(
\*FractionBox[\(n + 1\), \(\((n + 2)\)!\)]\((\(
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)]] ... \)
\*SubscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(n\)]]
\*SubscriptBox[\(F\), \(
\*SubscriptBox[\(\[Nu]\), \(i\)]
\*SubscriptBox[\(\[Mu]\), \(n + 1\)]\)])\)
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Mu]\), \(1\)]]\)\)...Subscript[dq, Subscript[\[Mu], n]]Subscript[dq, Subscript[\[Mu], n+1]] at a given operator dimension *)
PCDEDim[\[Nu]i_,dim_]:=Module[{n,coeff,qSec,Oper,mypoly},
If[MatchQ[\[Nu]i,Subscript[\[Mu], _]],
Print["PCDEDim[] called with invalid input \[Nu]i=",\[Nu]i];
Print["\!\(\*SubscriptBox[\(\[Mu]\), \(i\)]\) is reserved for dummy indices and cannot be used as open indices for PCDEDim[]."];
Print["Aborted."];
Abort[];
];
If[dim==0,Return[{{{{-1,Subscript[q, \[Nu]i]}},{},{0,0}}}]];
n=dim-2;
If[(!IntegerQ[n])||(n<0),Return[{}]];
coeff=-I (n+1)/(n+2)!;
qSec={Join[{coeff},Subscript[dq,Subscript[\[Mu],#]]&/@Range[n+1]]};
Oper={Join[Subscript[P,Subscript[\[Mu],#]]&/@Range[n],{Subscript[F,\[Nu]i,Subscript[\[Mu],n+1]]}]};
mypoly={{qSec,Oper,{dim,n+1}}};
Return[mypoly];
];

(* Poly X^CDE=(Subscript[q, Subscript[\[Nu], 1]]Subsuperscript[G, Subscript[\[Nu], 1]Subscript[\[Nu], 2], CDE]+\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubscriptBox[\(q\), 
SubscriptBox[\(\[Nu]\), \(1\)]]\))Subscript[dq, Subscript[\[Nu], 2]]-\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(3\)]\), \(CDE\)]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(2\)]]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(3\)]]\ at\ a\ given\ operator\ dimension\) *)
XCDEDim[dim_]:=Module[{poly1,poly2,poly3,polyArray,mypoly},
If[(!IntegerQ[dim])||(dim<2),Return[{}]];
(* the firt two terms (Subscript[q, Subscript[\[Nu], 1]]Subsuperscript[G, Subscript[\[Nu], 1]Subscript[\[Nu], 2], CDE]+\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubscriptBox[\(q\), 
SubscriptBox[\(\[Nu]\), \(1\)]]\))Subscript[dq, Subscript[\[Nu], 2]] *)
poly1={{{{Subscript[q, Subscript[\[Nu], 1]]}},{},{0,0}}};
poly2=GCDEDim[{Subscript[\[Nu], 1],Subscript[\[Nu], 2]},dim];
poly3={{{{Subscript[dq, Subscript[\[Nu], 2]]}},{},{0,0}}};
mypoly=Join[MultiplyPolys[{poly1,poly2,poly3}],MultiplyPolys[{poly2,poly1,poly3}]];
mypoly=CollectPoly[mypoly];
(* the last term -\!\(
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(2\)]\), \(CDE\)]
\*SubsuperscriptBox[\(G\), \(
\*SubscriptBox[\(\[Nu]\), \(1\)]
\*SubscriptBox[\(\[Nu]\), \(3\)]\), \(CDE\)]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(2\)]]
\*SubscriptBox[\(dq\), 
SubscriptBox[\(\[Nu]\), \(3\)]]\) *)
poly1=Join@@(MultiplyPolys[{GCDEDim[{Subscript[\[Nu], 1],Subscript[\[Nu], 2]},#],GCDEDim[{Subscript[\[Nu], 1],Subscript[\[Nu], 3]},dim-#]}]&/@Range[2,dim-2]);
poly1=CollectPoly[poly1];
poly2={{{{-1,Subscript[dq, Subscript[\[Nu], 2]],Subscript[dq, Subscript[\[Nu], 3]]}},{},{0,0}}};
poly3=MultiplyPolys[{poly1,poly2}];
(* sum the above terms *)
mypoly=Join[mypoly,poly3];
Return[mypoly];
];

(* Poly Subscript[\[CapitalDelta], i]Subscript[X\[CapitalDelta], i]Subscript[X\[CapitalDelta], i]...Subscript[X\[CapitalDelta], i] for a given dimpar of X *)
\[CapitalDelta]XStrDimPar[i_,dimpar_]:=Module[{polyDelta,polyArray,mypoly},
polyDelta={{{{Subscript[\[CapitalDelta], i]}},{},{0,0}}};
polyArray=MultiplyPolys[{polyDelta,XCDEDim[#]}]&/@dimpar;
mypoly=MultiplyPolys[Join[polyArray,{polyDelta}]];
Return[mypoly];
];

(* Poly Subscript[\[CapitalDelta], i]Subscript[X\[CapitalDelta], i]Subscript[X\[CapitalDelta], i]...Subscript[X\[CapitalDelta], i] with nX of X at a given operator dimension *)
\[CapitalDelta]XStrnX[i_,nX_,dim_]:=Module[{dimparArray,polyArray,mypoly},
If[(!IntegerQ[dim])||(dim<2nX),Return[{}]];
dimparArray=Flatten[Permutations/@IntegerPartitions[dim-nX,{nX}],1]+1;
mypoly=Join@@(\[CapitalDelta]XStrDimPar[i,#]&/@dimparArray);
mypoly=CollectPoly[mypoly];
Return[mypoly];
];

(* Poly Subsuperscript[\[CapitalDelta], i, CDE]=Subscript[\[CapitalDelta], i]+Subscript[\[CapitalDelta], i]X^CDESubscript[\[CapitalDelta], i]+Subscript[\[CapitalDelta], i]X^CDESubscript[\[CapitalDelta], i]X^CDESubscript[\[CapitalDelta], i]+... at a given operator dimension *)
\[CapitalDelta]CDEDimGen[i_,dim_]:=Module[{mypoly},
If[(!IntegerQ[dim])||(dim<0),Return[{}]];
mypoly=Join@@(\[CapitalDelta]XStrnX[i,#,dim]&/@Range[0,Floor[dim/2]]);
mypoly=CollectPoly[mypoly];
Return[mypoly];
];

(* Load the quantity \[CapitalDelta]CDEPolyCache that stores the pre-evaluated \[CapitalDelta]CDE polys for dim [0, 10] *)
Load\[CapitalDelta]CDEPolyCache[]:=Module[{},
\[CapitalDelta]CDEPolyCache=\[CapitalDelta]CDEDimGen[1,#]&/@Range[0,10];
Return[];
];

(* Poly Subsuperscript[\[CapitalDelta], i, CDE] at a given operator dimension *)
\[CapitalDelta]CDEDim[i_,dim_]:=Module[{},
If[(!IntegerQ[dim])||(dim<0),Return[{}]];
If[(!ValueQ[\[CapitalDelta]CDEPolyCache])||(dim>10),Return[\[CapitalDelta]CDEDimGen[i,dim]]];
Return[\[CapitalDelta]CDEPolyCache[[dim+1]]/.{Subscript[\[CapitalDelta], 1]->Subscript[\[CapitalDelta], i]}];
];


(* ::Subsection::Closed:: *)
(*Supertrace Manipulations*)


(* ::Text::Closed:: *)
(*Descriptions*)


(* ::Input::Initialization:: *)
(*
\!\(\(STrEAM\ evaluates\ functional\ supertraces\ of\ the\ form\[IndentingNewLine]\ \  - iSTr[f]\)
\*SubscriptBox[\(|\), \(hard\)]\);
where f a product sequence of Subscript[P, \[Mu]], Subscript[U, k], Subscript[\[CapitalDelta], i] and Subscript[\[CapitalLambda], i], consisting of an arbitrary number of "propagator blocks"
f=[ ... (\!\(
\*SubsuperscriptBox[\(P\), 
SubscriptBox[\(\[Mu]\), \(1\)], \(CDE\)] ... \)Subsuperscript[P, Subscript[\[Mu], n], CDE])(\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\ or\ 
\*SubsuperscriptBox[\(\[CapitalLambda]\), \(i\), \(CDE\)]\))(\!\(
\*SubsuperscriptBox[\(P\), 
SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)] ... \)Subsuperscript[P, Subscript[\[Nu], m], CDE])Subsuperscript[U, k, CDE] ... ];
where the propagator can be either bosonic Subsuperscript[\[CapitalDelta], i, CDE], or fermionic Subsuperscript[\[CapitalLambda], i, CDE]; the last Subsuperscript[U, k, CDE] factor is allowed to be absent;"Subscript[|, hard]" denotes the hard region contributions;

Fermionic propagators are addressed by
 Subsuperscript[\[CapitalLambda], i, CDE]=1/(Pslash-Subscript[m, i])=1/(P^2-Subsuperscript[m, i, 2]-\[CapitalSigma])(Subscript[m, i]+Subscript[P, \[Rho]]Subscript[\[Gamma], \[Rho]])=(\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)] + \(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) + \(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) + \)...)(Subscript[m, i]+Subscript[P, \[Rho]]Subscript[\[Gamma], \[Rho]]);
with
\[CapitalSigma]=-(1/2)\[Sigma]^\[Alpha]\[Beta]Subscript[F, \[Alpha]\[Beta]]=-(1/2)\[Sigma]F;
We call the supertrace "bosonic" when it contains no fermionic propagators;

Mandatory input parameters for the main function SuperTrace[];
dim          Desired operator dimension in the result;
flist        Functional operator f to trace over;

Options for the main function SuperTrace[];
Udimlist     default {1,...,1}    Minimum operator dimensions of {Subscript[U, k]};
Heavylist    default    {1}       Heavy mass labels;
SoftOrd      default     0        Additional power(s) of Subscript[m, light]/Subscript[m, heavy];
No\[Gamma]inU       default   False      No Dirac matrices Subscript[\[Gamma], \[Mu]] in {Subscript[U, k]} factors;
display      default   False      Print result;

Alternatively, one can use the function SuperTraceFromExpr, which takes an expression fexpr as input for the functional operator f;

The set of underlying supertrace "parameters" for the functional operator f (only used in private context);
masslabels   List of propagator masses, namely the {Subscript[i, 1],Subscript[i, 2],...} in f;
typelist     List of propagator types +1 for Subscript[\[CapitalDelta], i], -1 or Subscript[\[CapitalLambda], i];
coeff        Coefficient multiplying the supertrace;
Ulist        List of Subscript[U, k] factors, with default value {Subscript[U, 1],Subscript[U, 2],Subscript[U, 3],...};
Plocations   List of locations of Subsuperscript[P, Subscript[\[Nu], i], CDE], with -n(+n) indicating before(after) the nth propagator;
Pindices     List of Lorentz indices Subscript[\[Nu], i] in the open covariant derivatives Subsuperscript[P, Subscript[\[Nu], i], CDE];
Udimlist     List of minimum operator dimensions of {Subscript[U, k]};
*)


(* ::Subsubsection::Closed:: *)
(*Bosonic Supertrace CDE Poly Generation*)


(* ::Input::Initialization:: *)
Clear[STrPrint];
Clear[STrParameters];
Clear[STrBflists];
Clear[STrflistUFrame];
Clear[DimparsBSTr];
Clear[BSTrPolyDimPar];
Clear[BSTrPolyGen];


(* ::Input::Initialization:: *)
(* Print the input supertrace *)
STrPrint[flist_]:=Module[{mylist},
mylist=Flatten[Flatten[{ReplaceAll[#,{Times->List,NonCommutativeMultiply->List}]}]&/@flist];
mylist=Join[{Times@@(Select[mylist,NumericQ])},DeleteCases[mylist,_?NumericQ]];
If[mylist[[1]]===1,mylist=mylist[[2;;]]];
If[mylist[[1]]===-1,mylist=ReplacePart[mylist,1->"-"]];
mylist=mylist/.{Subscript[\[CapitalDelta], i_]->If[i==0,1/P^2,1/(P^2-\!\(\*SubsuperscriptBox[\(m\), \(i\), \(2\)]\))],Subscript[\[CapitalLambda], j_]->If[j==0,"\!\(\*FractionBox[\(1\), \(\(Pslash\)\(\\\ \)\)]\)",1/(Pslash - Subscript[m, j])]};
mylist=Join[{"-iSTr["},mylist,{"]\!\(\*SubscriptBox[\(|\), \(hard\)]\)"}];
Return[Row[mylist]];
];

(* Get the set of underlying supertrace "parameters" for flist *)
STrParameters[flist_,Udimlist_]:=Module[{myflist,masslabels,mytypelist,my\[CapitalDelta]split,mycoeff,PUframeArray,nUArray,Ucoefflist,Uoperlist,myUlist,myUdimlist,myP\[CapitalDelta]PUlist,myP\[CapitalDelta]PUsplit,myPlocations,myPindices,myParameters},
(* canonicalize flist into myflist *)
myflist=Join@@(Flatten[{ReplaceAll[#,{Times->List,NonCommutativeMultiply->List}]}]&/@flist);
If[!NumericQ[myflist[[1]]],myflist=Insert[myflist,1,1]];
(* masslabels and propagator types *)
masslabels=Cases[myflist,Subscript[\[CapitalDelta], i_]|Subscript[\[CapitalLambda], i_]->i];
mytypelist=Cases[myflist,Subscript[\[CapitalDelta], _]|Subscript[\[CapitalLambda], _]]/.{Subscript[\[CapitalDelta], _]->1,Subscript[\[CapitalLambda], _]->-1};
If[masslabels==={},
Print["Invalid input f."];
Print["f must be made of the propagator blocks f=[ ... (\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(n\)], \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) or \!\(\*SubsuperscriptBox[\(\[CapitalLambda]\), \(i\), \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(m\)], \(CDE\)]\))\!\(\*SubsuperscriptBox[\(U\), \(k\), \(CDE\)]\) ... ]."];
Print["No propagators detected: input flist=",flist];
Print["Aborted."];
Abort[];
];
If[(!AllTrue[masslabels,IntegerQ])||(Min[masslabels]<0),
Print["Invalid input f."];
Print["mass labels must be non-negative integers: input flist=",flist];
Print["Aborted."];
Abort[];
];
(* coeff, Ulist, and Udimlist *)
If[SequenceCount[DeleteCases[myflist,_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[Gamma], _]|Subscript[\[CurlyEpsilon], __]|Subscript[P, _]]/.{Subscript[\[CapitalDelta], _]|Subscript[\[CapitalLambda], _]->\[CapitalDelta]},{\[CapitalDelta],\[CapitalDelta]}]>0,
Print["Invalid input f."];
Print["f must be made of the propagator blocks f=[ ... (\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(n\)], \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) or \!\(\*SubsuperscriptBox[\(\[CapitalLambda]\), \(i\), \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(m\)], \(CDE\)]\))\!\(\*SubsuperscriptBox[\(U\), \(k\), \(CDE\)]\) ... ]."];
Print["Missing U factor between \[CapitalDelta]|\[CapitalLambda]: input flist=",flist];
Print["Aborted."];
Abort[];
];
my\[CapitalDelta]split=Split[myflist,!MatchQ[#2,Subscript[\[CapitalDelta], _]|Subscript[\[CapitalLambda], _]]&];
If[DeleteCases[my\[CapitalDelta]split[[1]],_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[CurlyEpsilon], __]|Subscript[P, _]]=!={},
Print["Invalid input f."];
Print["f must be made of the propagator blocks f=[ ... (\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(n\)], \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) or \!\(\*SubsuperscriptBox[\(\[CapitalLambda]\), \(i\), \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(m\)], \(CDE\)]\))\!\(\*SubsuperscriptBox[\(U\), \(k\), \(CDE\)]\) ... ]."];
Print["U factor found before the first propagator: input flist=",flist];
Print["Aborted."];
Abort[];
];
mycoeff=Times@@DeleteCases[my\[CapitalDelta]split[[1]],Subscript[P, _]];
my\[CapitalDelta]split=my\[CapitalDelta]split[[2;;]];
PUframeArray=DeleteCases[#,_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[Gamma], _]|Subscript[\[CurlyEpsilon], __]|Subscript[\[CapitalDelta], _]|Subscript[\[CapitalLambda], _]]&/@my\[CapitalDelta]split;
nUArray=(Length[Split[Join[{Subscript[P, 0]},#],!(MatchQ[#1,Subscript[P, _]]&&!MatchQ[#2,Subscript[P, _]])&]]&/@PUframeArray)-1;
If[Max[nUArray]>1,
Print["Invalid input f."];
Print["f must be made of the propagator blocks f=[ ... (\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(n\)], \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) or \!\(\*SubsuperscriptBox[\(\[CapitalLambda]\), \(i\), \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(m\)], \(CDE\)]\))\!\(\*SubsuperscriptBox[\(U\), \(k\), \(CDE\)]\) ... ]."];
Print["More than one U factors found between two adjacent propagators: input flist=",flist];
Print["Aborted."];
Abort[];
];
Ucoefflist=(Times@@Cases[#,_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[CurlyEpsilon], __]])&/@my\[CapitalDelta]split;
Uoperlist=DeleteCases[#,_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[CurlyEpsilon], __]|Subscript[\[CapitalDelta], _]|Subscript[\[CapitalLambda], _]|Subscript[P, _]]&/@my\[CapitalDelta]split;
Uoperlist=If[Length[#]>1,#/.List->NonCommutativeMultiply,#/.List->Times]&/@Uoperlist;
myUlist=MapThread[#1 #2&,{Ucoefflist,Uoperlist}];
If[(Length[Udimlist]!=0)&&(Length[Udimlist]!=Length[myUlist]),
Print["Invalid input option Udimlist."];
Print["Length of Udimlist does not match number of U factors: Ulist=",myUlist,", Udimlist=",Udimlist];
Print["Aborted."];
Abort[];
];
myUdimlist=Udimlist; If[myUdimlist==={},myUdimlist=1&/@myUlist];
If[DeleteCases[Last[my\[CapitalDelta]split],_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[Gamma], _]|Subscript[\[CurlyEpsilon], __]|Subscript[\[CapitalDelta], _]|Subscript[\[CapitalLambda], _]|Subscript[P, _]]==={},
If[(Length[Udimlist]!=0)&&Last[Udimlist]!=0,
Print["Invalid input option Udimlist."];
Print["Nonzero last Udimlist for trivial last U factor: Ulist=",myUlist,", Udimlist=",Udimlist];
Print["Aborted."];
Abort[];
];
myUdimlist[[-1]]=0;
];
(* Plocations and Pindices *)
myP\[CapitalDelta]PUlist=DeleteCases[myflist,_?NumericQ|Subscript[m, _]|Subscript[\[Eta], __]|Subscript[\[Gamma], _]|Subscript[\[CurlyEpsilon], __]]/.{Subscript[P, _]->P,Subscript[\[CapitalDelta], _]|Subscript[\[CapitalLambda], _]->\[CapitalDelta]};
myP\[CapitalDelta]PUsplit=Split[myP\[CapitalDelta]PUlist,(MatchQ[#1,\[CapitalDelta]|P]||!MatchQ[#2,\[CapitalDelta]|P])&];
If[Length[myP\[CapitalDelta]PUsplit]>Length[masslabels],
Print["Invalid input f."];
Print["f must be made of the propagator blocks f=[ ... (\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Mu]\), \(n\)], \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) or \!\(\*SubsuperscriptBox[\(\[CapitalLambda]\), \(i\), \(CDE\)]\))(\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(1\)], \(CDE\)]\)...\!\(\*SubsuperscriptBox[\(P\), SubscriptBox[\(\[Nu]\), \(m\)], \(CDE\)]\))\!\(\*SubsuperscriptBox[\(U\), \(k\), \(CDE\)]\) ... ]."];
Print["\!\(\*SubscriptBox[\(P\), \(\[Mu]\)]\) factors after the last U factor detected: input flist=",flist];
Print["Aborted."];
Abort[];
];
myP\[CapitalDelta]PUsplit=MapThread[(Cases[#1,P|\[CapitalDelta]]/.{P->0,\[CapitalDelta]->#2})&,{myP\[CapitalDelta]PUsplit,Range[Length[myP\[CapitalDelta]PUsplit]]}];
myPlocations=Join@@(DeleteCases[Accumulate[#]-Reverse[Accumulate[Reverse[#]]],0]&/@myP\[CapitalDelta]PUsplit);
myPindices=Cases[myflist,Subscript[P, \[Nu]_]->\[Nu]];
If[Length[myPindices]!=Length[myPlocations],
Print["Length mismatch between Plocations and Pindices:"];
Print["Plocation=",myPlocations,", Pindices=",myPindices];
Print["Aborted."];
Abort[];
];
(* put all the inputs together *)
myParameters={masslabels,mytypelist,mycoeff,myUlist,myPlocations,myPindices,myUdimlist};
Return[myParameters];
];

(* Get the set of bosonic flists from a given flist by Subsuperscript[\[CapitalLambda], i, CDE]=(\!\(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)] + \(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) + \(
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]
\*SuperscriptBox[\(\[CapitalSigma]\), \(CDE\)]
\*SubsuperscriptBox[\(\[CapitalDelta]\), \(i\), \(CDE\)]\) + \)...)(Subscript[m, i]+Subscript[P, \[Rho]]Subscript[\[Gamma], \[Rho]]) *)
STrBflists[flist_,n\[CapitalSigma]cap_,n\[Nu]_]:=Module[{bflistTuples,\[Nu]shiftArray,bflistArray},
bflistTuples=Tuples[(If[MatchQ[#,Subscript[\[CapitalLambda], __]],#,{{#}}]&/@flist)/.{Subscript[\[CapitalLambda], i_]:>Flatten/@Tuples[{NestList[Join[#,{-(1/2),\[Sigma]F,Subscript[\[CapitalDelta], i]}]&,{Subscript[\[CapitalDelta], i]},n\[CapitalSigma]cap],
DeleteCases[{{Subscript[m, i],1},{Subscript[P, Subscript[\[Mu], 0]],1,Subscript[\[Gamma], Subscript[\[Mu], 0]]}},_?(MemberQ[#,Subscript[m, 0]]&)]}]}];
\[Nu]shiftArray=Join[{0},Accumulate[(Count[#,Subscript[\[Mu], 0],All]&/@#)[[;;-2]]]/2]&/@bflistTuples;
bflistArray=Flatten/@MapThread[MapThread[#1/.{Subscript[\[Mu], 0]->Subscript[\[Nu], n\[Nu]+1+#2]}&,{#1,#2}]&,{bflistTuples,\[Nu]shiftArray}];
bflistArray=Select[bflistArray,(Count[#,\[Sigma]F]<=n\[CapitalSigma]cap)&];
Return[bflistArray];
];

(* Obtain the UFrame of flist *)
STrflistUFrame[masslabels_,typelist_,coeff_,Plocations_,Pindices_]:=Module[{myUlist,\[CapitalDelta]lsit,\[CapitalDelta]Ulist,poslist,Porders,myflist},
myUlist=Subscript[U, #]&/@Range[Length[masslabels]];
\[CapitalDelta]lsit=MapThread[If[#2>0,Subscript[\[CapitalDelta],#1],Subscript[\[CapitalLambda],#1]]&,{masslabels,typelist}];
\[CapitalDelta]Ulist=Riffle[\[CapitalDelta]lsit,myUlist];
poslist={If[#>0,2#,-2#-1]}&/@Plocations;
myflist=Insert[\[CapitalDelta]Ulist,P,poslist];
Porders=Accumulate[If[#===P,1,0]&/@myflist];
myflist=MapThread[If[#1===P,Subscript[P,Pindices[[#2]]],#1]&,{myflist,Porders}];
myflist=Join[{coeff},myflist];
Return[myflist];
];

(* Get the list of dimpars of a given operator dimension for a bosonic supertrace *)
DimparsBSTr[dim_,masslabels_,Plocations_,Udimlist_]:=Module[{\[CapitalDelta]mindim,Umindim,mindimlist,poslist,ULastdim,dimparshift,dimeff,mydimparlist},
\[CapitalDelta]mindim=0&/@masslabels;
Umindim=Udimlist;
mindimlist=Riffle[\[CapitalDelta]mindim,Umindim];
poslist={If[#>0,2#,-2#-1]}&/@Plocations;
mindimlist=Insert[mindimlist,0,poslist];
ULastdim=Last[Udimlist];
mindimlist=mindimlist[[;;-2]];
dimparshift=mindimlist-1;
dimeff=dim-ULastdim-(Plus@@dimparshift);
mydimparlist=Flatten[Permutations/@IntegerPartitions[dimeff,{Length[mindimlist]}],1];
mydimparlist=Join[#+dimparshift,{ULastdim}]&/@mydimparlist;
(* trimings *)
If[!MemberQ[Plocations,-1],mydimparlist=Select[mydimparlist,#[[1]]!=2&]];
If[!MemberQ[Plocations,Length[masslabels]],mydimparlist=Select[mydimparlist,#[[-2]]!=2&]];
Return[mydimparlist];
];

(* Generate the poly of a bosonic supertrace for a given dimpar *)
BSTrPolyDimPar[dimpar_,masslabels_,coeff_,Ulist_,Plocations_,Pindices_,Udimlist_]:=Module[{mytypelist,mylist,myexpr,polyArray,mypoly},
mytypelist=1&/@masslabels;
mylist=STrflistUFrame[masslabels,mytypelist,1,Plocations,Pindices];
mylist=mylist[[2;;]];
polyArray=MapThread[(#1/.{Subscript[\[CapitalDelta], i_]:>\[CapitalDelta]CDEDim[i,#2],Subscript[U, k_]:> UCDEDim[#2,Udim->Udimlist[[k]],Uoper->Ulist[[k]]],Subscript[P, \[Nu]_]:>PCDEDim[\[Nu],#2]})&,{mylist,dimpar}];
mypoly=MultiplyPolys[polyArray];
mypoly=SimplifyPoly[mypoly];
mypoly=FTrimPoly[mypoly];
mypoly=ReplacePart[#,1->ScaleqSec[#[[1]],coeff]]&/@mypoly;
Return[mypoly];
];

(* Generate the poly of a bosonic supertrace up to a given operator dimension *)
BSTrPolyGen[dim_,masslabels_,coeff_,Ulist_,Plocations_,Pindices_,Udimlist_]:=Module[{mindim,mydimparArray,polyArray,myexpr,mypoly},
mindim=Plus@@Udimlist; If[mindim==0,mindim=1];
mydimparArray=Flatten[DimparsBSTr[#,masslabels,Plocations,Udimlist]&/@Range[mindim,dim],1];
polyArray=BSTrPolyDimPar[#,masslabels,coeff,Ulist,Plocations,Pindices,Udimlist]&/@mydimparArray;
mypoly=SimplifyPoly[Join@@polyArray];
Return[mypoly];
];


(* ::Subsubsection::Closed:: *)
(*General Supertrace (Main Functions)*)


(* ::Input::Initialization:: *)
Clear[SuperTrace]; 
Clear[SuperTraceFromExpr];


(* ::Input::Initialization:: *)
(* \!\(\(Compute\ a\ functional\ supertrace\  - iSTr[f]\)
\*SubscriptBox[\(|\), \(hard\)]\ \(up\ to\ a\ given\ operator\ dimension\ dim\)\) *)
SuperTrace[dim_,flist_,OptionsPattern[{Udimlist->{},Heavylist->{1},SoftOrd->0,No\[Gamma]inU->False,display->False}]]:=Module[{myflist,indices,n\[Nu],\[Mu]start,Parameters,masslabels,typelist,coeff,Ulist,Plocations,Pindices,myUdimlist,myHeavylist,mySoftOrd,supersign,flistU,n\[CapitalSigma]cap,bflistArray,UdimlistArray,BSTrInputArray,showstatus,mypoly,myInput,myPrint,mystr},
(**)
(*************************************************************************************)
(********************************** Interpret Inputs ***********************************)
(*************************************************************************************)
(**)
myflist=flist;
indices=Cases[myflist,Subscript[_, a__]->a];
n\[Nu]=Max[Join[{0},Cases[indices,Subscript[\[Nu], i_]->i]]];
If[MemberQ[indices,Subscript[\[Mu], _]],
\[Mu]start=Min[Cases[indices,Subscript[\[Mu], i_]->i]];
myflist=myflist/.{Subscript[\[Mu], i_]->Subscript[\[Nu], n\[Nu]+i-\[Mu]start+1]};
Print["\[Mu] indices are reserved by the package STrEAM as internal dummy indices."];
Print["Proceeding with the following indices replacements:"];
Print[Subscript[\[Mu], #]->Subscript[\[Nu], n\[Nu]+#-\[Mu]start+1]]&/@Sort[DeleteDuplicates[Cases[indices,Subscript[\[Mu], i_]->i]]];
n\[Nu]=Max[Join[{0},Cases[Cases[myflist,Subscript[_, a__]->a],Subscript[\[Nu], i_]->i]]];
];
If[Count[Tally[DeleteCases[indices,_?NumericQ]],_?(#[[2]]>2&)]>0,
Print["SuperTrace[] called with invalid input flist=",myflist];
Print["Lorentz indices: ",DeleteCases[indices,_?NumericQ]];
Print["The same Lorentz index should not appear more than twice."];
Print["Aborted."];
Abort[];
];
Parameters=STrParameters[myflist,OptionValue[Udimlist]];
masslabels=Parameters[[1]];
typelist=Parameters[[2]];
coeff=Parameters[[3]];
Ulist=Parameters[[4]];
Plocations=Parameters[[5]];
Pindices=Parameters[[6]];
myUdimlist=Parameters[[7]];
(**)
(*************************************************************************************)
(******************************* Check Validity of Options ******************************)
(*************************************************************************************)
(**)
(* Heavylist *)
myHeavylist=OptionValue[Heavylist];
If[Intersection[masslabels,myHeavylist]==={},
Print["SuperTrace[] called with an flist containing no heavy mass:"];
Print["flist=",myflist];
Print["masslabels=",masslabels];
Print["Heavylist=",myHeavylist];
Print["In this case, Supertrace[f]=-iSTr[f]\!\(\*SubscriptBox[\(|\), \(hard\)]\) vanishes."];
Return[{}];
];
(* SoftOrd *)
mySoftOrd=OptionValue[SoftOrd];
If[(!IntegerQ[mySoftOrd])||(mySoftOrd<0),
Print["SuperTrace[] called with invalid option SoftOrd=",mySoftOrd];
Print["SoftOrd must be non-negative integers."];
Print["Aborted."];
Abort[];
];
(**)
(*************************************************************************************)
(******************************* Evaluate the SuperTrace ********************************)
(*************************************************************************************)
(**)
(* Address the "super" in STr *)
supersign=typelist[[1]];
coeff=supersign*coeff;
(**)
(* Address fermionic propagators *)
flistU=STrflistUFrame[masslabels,typelist,coeff,Plocations,Pindices];
n\[CapitalSigma]cap=Floor[(dim-(Plus@@myUdimlist))/2];If[n\[CapitalSigma]cap<0,n\[CapitalSigma]cap=0];
bflistArray=STrBflists[flistU,n\[CapitalSigma]cap,n\[Nu]];
UdimlistArray=(Cases[#,\[Sigma]F|Subscript[U, __]]/.{\[Sigma]F->2,Subscript[U, i_]:>myUdimlist[[i]]})&/@bflistArray;
bflistArray=(#/.{Subscript[U, i_]:>Ulist[[i]]})&/@bflistArray;
BSTrInputArray=MapThread[STrParameters[#1,#2]&,{bflistArray,UdimlistArray}];
BSTrInputArray=Join[{dim},Delete[#,2]]&/@BSTrInputArray;
(**)
(* Perform original CDE *)
mypoly=Join@@((BSTrPolyGen@@#)&/@BSTrInputArray);
mypoly=SimplifyPoly[mypoly];
showstatus=False;
If[Plus@@(Length[#[[1]]]&/@mypoly)>200,showstatus=True];
If[showstatus,Print["Poly generated. Number of terms:\n\t",Plus@@(Length[#[[1]]]&/@mypoly)]];
(**)
(* Perform loop integrals *)
mypoly=qEvenTrimPoly[mypoly];
mypoly=dqAllPoly[mypoly];
mypoly=SimplifyPoly[mypoly];
If[showstatus,Print["q-derivatives carried out. Number of terms:\n\t",Plus@@(Length[#[[1]]]&/@mypoly)]];
mypoly=FTrimPoly[mypoly];
mypoly=SymHardPoly[mypoly,dim,myHeavylist,mySoftOrd,OptionValue[No\[Gamma]inU]];
If[showstatus,Print["Expanded in hard region. Number of terms:\n\t",Plus@@(Length[#[[1]]]&/@mypoly)]];
mypoly=IntegratePoly[mypoly];
If[showstatus,
Print["Loop integrals done. Number of terms:\n\t",Plus@@(Length[#[[1]]]&/@mypoly)];
Print[Graphics[Line[{{0,0},{100,0}}],ImageSize->600]];
];
mystr=ReplacePart[#,3->#[[3]][[1]]]&/@mypoly;
mystr=mystr/.{Log[\!\(\*SubsuperscriptBox[\(m\), \(i_\), \(2\)]\)]->Log[\!\(\*SubsuperscriptBox[\(m\), \(i\), \(2\)]\)/\[Mu]^2]};
(**)
(* Print results *)
If[OptionValue[display],
myInput=STrPrint[myflist];
myPrint=ReplacePart[#,2->{{Row[Row[Join[{"("},{Row[#]},{")"}]]&/@(#[[2]])]}}]&/@mystr;
myPrint=ReplacePart[#,3->{{Row[{"(dim-",#[[3]],")"}]}}]&/@myPrint;
Print[myInput," = \[Integral]\!\(\*SuperscriptBox[\(d\), \(4\)]\)x \!\(\*FractionBox[\(1\), \(16 \*SuperscriptBox[\(\[Pi]\), \(2\)]\)]\) tr{\n",TableForm[myPrint,TableSpacing->{5,5,2}],"\n}"];
];
Return[mystr];
];

(* \!\(\(Compute\ a\ functional\ supertrace\  - iSTr[f]\)
\*SubscriptBox[\(|\), \(hard\)]\ \(up\ to\ a\ given\ operator\ dimension\ dim\)\) *)
SuperTraceFromExpr[dim_,fexpr_,OptionsPattern[{Udimlist->{},Heavylist->{1},SoftOrd->0,No\[Gamma]inU->False,display->False}]]:=Module[{myflist,mystr},
myflist=Flatten[{fexpr/.{Times->List,NonCommutativeMultiply->List}}];
mystr=SuperTrace[dim,myflist,Udimlist->OptionValue[Udimlist],Heavylist->OptionValue[Heavylist],SoftOrd->OptionValue[SoftOrd],No\[Gamma]inU->OptionValue[No\[Gamma]inU],display->OptionValue[display]];
Return[mystr];
];


(* ::Section:: *)
(*End the `Private context*)


(* ::Input::Initialization:: *)
End[]


(* ::Section:: *)
(*End the package context*)


(* ::Input::Initialization:: *)
EndPackage[]
